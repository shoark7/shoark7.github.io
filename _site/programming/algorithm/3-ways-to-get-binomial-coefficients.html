<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>[조합론] 이항계수 알고리즘 3가지 - Parkito's on the way</title>

  <!-- Edit site and author settings in `_config.yml` to make the social details your own -->

    <meta content="Parkito's on the way" property="og:site_name">
  
    <meta content="[조합론] 이항계수 알고리즘 3가지" property="og:title">
  
  
    <meta content="article" property="og:type">
  
  
    <meta content="I introduce 3 algorithms to get binomial coefficient." property="og:description">
  
  
    <meta content="http://localhost:4000/programming/algorithm/3-ways-to-get-binomial-coefficients" property="og:url">
	
  
    <meta content="2018-10-23T00:00:00+09:00" property="article:published_time">
    <meta content="http://localhost:4000/about/" property="article:author">
  
  
    <meta content="http://localhost:4000/assets/img/algorithm/logo-binomial-coefficient.png" property="og:image">
  
  
    
    <meta content="Programming" property="article:section">
    
  
  
    
    <meta content="Algorithm" property="article:tag">
    
    <meta content="binomial_coefficient" property="article:tag">
    
  

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
  
    <meta name="twitter:title" content="[조합론] 이항계수 알고리즘 3가지">
  
  
    <meta name="twitter:url" content="http://localhost:4000/programming/algorithm/3-ways-to-get-binomial-coefficients">
  
  
    <meta name="twitter:description" content="I introduce 3 algorithms to get binomial coefficient.">
  
  
    <meta name="twitter:image:src" content="http://localhost:4000/assets/img//algorithm/logo-binomial-coefficient.png">
  

  
    <meta content="I introduce 3 algorithms to get binomial coefficient." name="description">
  
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="shortcut icon" href="/assets/img/favicon/favicon.ico" type="image/x-icon">
	<link rel="apple-touch-icon" href="/assets/img/favicon/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicon/apple-touch-icon-144x144.png">
	<!-- Chrome, Firefox OS and Opera -->
	<meta name="theme-color" content="#263959">
	<!-- Windows Phone -->
	<meta name="msapplication-navbutton-color" content="#263959">
	<!-- iOS Safari -->
	<meta name="apple-mobile-web-app-status-bar-style" content="#263959">
	<!-- Google Fonts -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=PT+Serif:400,700" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet">

	<!-- Font Awesome -->
	<link rel="stylesheet" href="/assets/fonts/font-awesome/css/font-awesome.min.css">
	<!-- Styles -->
	<!-- Mathjax Support -->

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

<script>
 //MathJax.Hub.Register.StartupHook('TeX Jax Ready', function () {
 //	MathJax.InputJax.TeX.prefilterHooks.Add(function (data) {
 //		data.math = data.math.replace(/^% <!\[CDATA\[/, '').replace(/%\]\]>$/, '');
 //	});
 //});
</script>

<!--
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
	MathJax.Hub.Config({
  showProcessingMessages: false,
  jax: ["input/TeX", "output/HTML-CSS"],
  TeX: {
    TagSide: "left",
    Macros: {
      RR: '{\\bf R}',
      bold: ['{\\bf #1}',1]
    }
  },
  CommonHTML: {
    linebreaks: {automatic: true}
  }
});
</script>
-->

	<link rel="stylesheet" href="/assets/css/main.css">
	<link rel="stylesheet" href="/assets/css/personal.css">
	<link href="https://fonts.googleapis.com/css?family=Do+Hyeon|Nanum+Gothic:400,700,800&amp;subset=korean" rel="stylesheet">

	<!-- googld ads tag -->
  <script data-ad-client="ca-pub-2670967175857332" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>

<body style="position: relative">
	<div id="toggler-wrapper">
		<div id="menu-toggler">
			<img src="/assets/img/nav-off.png" alt="Menu collapse image">
		</div>
	</div>

  <div class="wrapper">

		<nav id="nav">
			<div id="menus">
				<p>
					<a class="navbar-brand text-white" href="/">&nbsp;&nbsp;&nbsp;Parkito's on the way!&nbsp;&nbsp;&nbsp;</a>
				</p>
				<ul id="category-list">
					<li>
						<a href="/about.me">
							<div class="menu">
								<span> About </span>
							</div>
						</a>
					</li>
				
					<li>
						<div class="menu-wrapper">
							<a href="/category/programming">
								<div class="menu">
									<span> Programming </span>
								</div>
							</a>
							<div class="menu-item">
								<a href="/category/programming/knowledge">Knowledge</a>
								<a href="/category/programming/algorithm">Algorithm</a>
								<a href="/category/programming/python">Python</a>
								<a href="/category/programming/shell-programming">Shell programming</a>
							</div>
						</div>
					</li>
				
					<li>
						<div class="menu-wrapper">
								<a href="/category/insight">
									<div class="menu">
										<span> Insight </span>
									</div>
								</a>
								<div class="menu-item">
									<a href="/category/insight/sensitivity">&nbsp;&nbsp;Sensitivity&nbsp;&nbsp;</a>
									<a href="/category/insight/rationality">&nbsp;&nbsp;Rationality&nbsp;&nbsp;</a>
								</div>
						</div>
					</li>

					<li>
						<div class="menu-wrapper">
								<a href="/category/projects">
									<div class="menu">
										<span> Projects </span>
									</div>
								</a>
							<div class="menu-item">
								<a href="/category/projects/dev-related">&nbsp;&nbsp;Dev related&nbsp;&nbsp;</a>
								<a href="/category/projects/etc">&nbsp;&nbsp;ETC&nbsp;&nbsp;</a>
							</div>
						</div> </li>

				</ul>
			</div>

			<div id="menus-right">
				<div id="search-section">
					<div class="input-wrapper">
						<span class="fa fa-search"></span>
						<input type="text" id="search-input" placeholder="Please input specific keyword :)" size="30">
					</div>
					<div id="results-container"></div>
				</div>

				<!--<div id="toggler-wrapper">-->
					<!--<div id="menu-toggler">-->
						<!--<img src="/assets/img/nav-off.png" alt="" width="35px" height="35px">-->
					<!--</div>-->
				<!--</div>-->
				
			</div>
			
		</nav>


    <aside class="sidebar">
  <header>
    <div class="about">
      <div class="cover-author-image">
        <a href="/"><img src="/assets/img/1536558558520.jpg" alt="Sunghwan Park"></a>
      </div>
      <div class="author-name">Sunghwan Park</div>
      <p>I'm Parkito. A Python lover. Interested in Python, Automation, Algorithm. Please give me insights. I'll teach you tambien! :)</p>
    </div>
  </header> <!-- End Header -->
  <footer>
    <section class="contact">
      <h3 class="contact-title">Contact me</h3>
      <ul>
				<!--
        
          <li><a href="https://twitter.com/artemsheludko_" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
        
        
          <li><a href="https://facebook.com/" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a></li>
        
				-->
        
          <li class="github"><a href="http://github.com/shoark7" target="_blank"><i class="fa fa-github"></i></a></li>
        
        
          <li class="linkedin"><a href="https://in.linkedin.com/in/sunghwan-park-3773b8154" target="_blank"><i class="fa fa-linkedin"></i></a></li>
        
        
          <li class="email"><a href="mailto:shoark7@gmail.com"><i class="fa fa-envelope-o"></i></a></li>
        
      </ul>
    </section> <!-- End Section Contact -->
    <div class="copyright">
      <p>2021 &copy; Sunghwan Park</p>
    </div>
  </footer> <!-- End Footer -->
</aside> <!-- End Sidebar -->

<div class="content-box clearfix">
  <article class="article-page">
  <div class="page-content">
    
    <div class="page-cover-image">
      <figure>
        <img class="page-image" src=/assets/img//algorithm/logo-binomial-coefficient.png alt="[조합론] 이항계수 알고리즘 3가지">
        
      </figure>
    </div> <!-- End Page Cover Image -->
    
    <div class="wrap-content">
      <header class="header-page">
        <h1 class="page-title">[조합론] 이항계수 알고리즘 3가지</h1>
        <div class="page-date"><span>2018, Oct 23&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
      </header>

		<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
		<!-- 처음과끝에만 -->
		<ins class="adsbygoogle"
				 style="display:block"
				 data-ad-client="ca-pub-2670967175857332"
				 data-ad-slot="3352812061"
				 data-ad-format="auto"
				 data-full-width-responsive="true"></ins>
		<script>
				 (adsbygoogle = window.adsbygoogle || []).push({});
		</script>
		<!-- 처음과끝에만 -->

      <h2 id="들어가며">들어가며</h2>

<hr />

<p>이항계수는 내 기억에 고등학교 수준에서 배웠던 경우의 수 개념으로 나를 한동안 괴롭혔던 문제이다. 가령 “‘a’, ‘b’, ‘c’ 중 2개를 선택해 뽑는 조합을 모두 출력하라”와 같은 문제를 난 오랫동안 헤맸었는데 이제는 쉬운 풀이는 할 수 있는 수준이다.</p>

<p>그런데 조합의 경우  각각을 출력하는 것이 아닌 조합의 경우의 수 자체를 구하는 것은 꽤나 쉬운 일이다. 개념적으로 어렵지 않은 수식을 활용해 팩토리얼로 바로 구할 수 있기 때문이다. 프로그래밍에서도 똑같이 구현할 수 있다. 그러나 문제를 해결하는 방법은 보통 여러 가지일 때가 많고 이들을 모두 살펴보면 배울 것이 많다. 그건 이항계수도 마찬가지이다.</p>

<p><strong>이번 포스트는 이항계수를 구하는 서로 다른 세 가지 알고리즘을 확인해보려고 한다.</strong> 첫 번째는 가장 쉬운 구현, 두 번째는 동적 계획법을 활용한 구현, 세 번째는 동적 계획법을 활용한 또다른 구현이다. <strong>특히 세 번째 구현이 매우 의미가 있는데 <code class="highlighter-rouge">확장성</code>이라는 측면에서 다른 두 알고리즘의 추종을 불허한다.</strong> 첫 두 알고리즘은 알고 있었어도 세 번째는 몰랐을 수 있으니 확인 바란다.</p>

<h2 id="이항계수란">이항계수란?</h2>

<hr />

<p>이항계수(Binomial Coefficient)는 조합론에서 등장하는 개념으로 주어진 크기 집합에서 원하는 개수만큼 순서없이 뽑는 조합의 가짓수를 일컫는다. 2를 상징하는 ‘이항’이라는 말이 붙은 이유는 하나의 아이템에 대해서는 ‘뽑거나, 안 뽑거나’ 두 가지의 선택만이 있기 때문이다. 이 개념을 모르는 사람은 없을 것이라 생각한다.</p>

<p>전체 집합에서 원소의 개수 n에 대해 k개의 아이템을 뽑는 이항계수(조합의 수)는 다음과 같이 정의한다.</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}  \label{x1}
	\binom{n}{k} = n C k = \frac{n!}{(n-k)!k!} (단, 0 \le k \le n) && \cdots && 1
\end{align} %]]></script>

<p>위 공식을 이용해서 4개의 집합 중에서 2개를 순서없이 고르는 조합의 수는 ‘4! / 2! / 2!’, 즉 6이 된다. 이는 고등학교에서 배운 조합의 개념과 일치한다. 후에 설명할 팩토리얼을 사용한 이항계수 구현은 이 공식을 그대로 이용한다.</p>

<p>추가적으로 중요한 이항계수의 성질은 다음과 같다.</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align} \label{x2}
	\binom{n}{k} &= \binom{n}{n-k} && \cdots && 2
	\\
	\\
	\binom{n}{k} &= \binom{n-1}{k} + \binom{n-1}{k-1} && \cdots && 3
	\\
	\\
	\sum_{k=0}^{n} \binom{n}{k} &= 2^n && \cdots && 4
\end{align} %]]></script>

<p>2번은 조금만 생각해보면 상식적이다. <strong>n개 중에서 k개를 간택하는 것은 선택받지 못할 나머지 (n-k)개를 선택하는 것과 같다.</strong><br />
3번은 언뜻 보면 ‘뭐지?’ 할 수 있는데 이항계수의 정의식을 조작하면 2번식을 유도할 수 있다. 직접 해보는 것을 추천한다. 알고리즘을 공부하는 사람이라면 이 식은 기본적으로 외우고 있어야 하는 식이다. 이후 동적 계획법 알고리즘에서 사용할 것이다.<br />
4번은 <a href="https://ko.wikipedia.org/wiki/%ED%8C%8C%EC%8A%A4%EC%B9%BC%EC%9D%98_%EC%82%BC%EA%B0%81%ED%98%95" target="\_blank">파스칼의 삼각형</a>과 관련이 깊다.</p>

<p>우리의 구현은 언급한 특성 중 1번과 2번을 사용한다. 그리고 남은 알고리즘 하나는 이 성질과는 직접적인 상관이 없는 직관성으로 구현할 것이다.</p>

<p>구현을 시작해보자!</p>

<h2 id="1-팩토리얼-이항계수의-정의-이용하기">1. 팩토리얼: 이항계수의 정의 이용하기</h2>

<hr />

<p>이항계수의 정의를 이용한 방식은 팩토리얼을 사용한다. 팩토리얼은 파이썬에서는 <code class="highlighter-rouge">math</code> 모듈에서 지원하고 있지만 어렵지도 않은 거 그냥 구현하기로 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">ans</span> <span class="o">*=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">ans</span>


<span class="k">def</span> <span class="nf">bino_coef_factorial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">//</span> <span class="n">factorial</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">r</span><span class="p">)</span>
</code></pre></div></div>

<p>팩토리얼을 사용한 무난한 이항계수 알고리즘이다. 1번 정의를 충분히 활용했다. <strong>주의할 점은 <code class="highlighter-rouge">factorial</code> 함수가 <em>‘0!’</em> 도 1을 문제없이 반환할 수 있도록 하는 것이다.</strong> 그렇지 않으면 밑의 이항계수 함수가 <em>ZeroDivisionError</em> 를 일으킬 수 있다.</p>

<p>이 함수는 잘 작동하지만 잠재적인 위험성이 있다. 기본적으로 팩토리얼은 지수 증가보다도 크게 증가하는데 <em>n</em> 이 15만 되어도 1조를 훌쩍 넘겨버린다. 파이썬에서는 상관없지만, 타 언어에서는 구하는 수가 매우 크지 않더라도 오버플로우가 쉽게 발생할 수 있기 때문에 주의해서 사용해야 한다. 물론 우리의 사랑스러운 파이썬에서는 일반적으로 오버플로우를 걱정하지 않고 이 함수를 이용할 수 있다. :)</p>

<h2 id="2-동적-계획법-1-이항계수의-성질-이용하기">2. 동적 계획법 1: 이항계수의 성질 이용하기</h2>

<hr />

<p>이제 좀 알고리즘답게 풀어볼 시간이다. 바로 동적 계획법을 사용한 방법인데 언제나 이야기하지만 동적 계획법이라는 용어는 난해한 용어를 좋아하는 전문가들을 전문가답게 만들어주는 용어고 <strong>일반인이 이해하기에는 ‘기억하며 풀기’라고 생각하면 된다.</strong></p>

<p>이 방법은 앞서 살펴본 이항계수의 성질 중 2번과 3번을 활용해 문제를 푼다. 2번을 통해 우리는 다음을 알 수 있다.</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}  \label{x3}
	\binom{n}{0} = \binom{n}{n} = 1 && \cdots && 2.1
\end{align} %]]></script>

<p><strong>전체 집합에서 아무것도 고르지 않는 방법은 1가지이고, 동시에 모두를 선택하는 것도 1가지 방법뿐이다. 그리고 3번 성질을 이용하면 이항계수를 그보다 작은 두 개의 부분식으로 쪼갤 수 있고 이 식들은 더 잘게 계속계속 쪼개질 수 있다. 쪼개지면서 n과 k가 점차 작아지는데 k가 0이 되는 순간과 n과 k가 같아지는 순간은 무조건 1이다.</strong> 성질에 의해 정의된 것이니까.</p>

<p>이 개념을 파이썬으로 재귀적으로 구현하면 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bino_coef</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">bino_coef</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">bino_coef</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">bino_coef</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="mi">6</span>
</code></pre></div></div>

<p>간단한 재귀함수의 활용이다. 이는 2.1번과 3번 성질을 그대로 활용했다. 결과는 나오지만 이 함수는 치명적인 문제를 안고 있다. 바로 <strong>부분문제의 중복(overlapping subproblems)으로 이 때문에 함수의 성능이 치명적으로 나쁘다.</strong></p>

<p><img src="/assets/img/algorithm/fibbonacci-recurisive.png" alt="overlapping-subproblems" /></p>

<p><code class="highlighter-rouge">부분문제의 중복</code>이라는 현상을 설명하기 위해 비슷한 예제인 피보나치 수열에 대한 반복구현의 실행흐름을 가져왔다.</p>

<p>피보나치 수열은 n번째 항을 n-1번째 항과 n-2번째 항의 합으로 표현한 수열로 위의 <em>fib</em> 함수는 실행 시 두 개로 갈라진다. 이항계수 함수도 둘로 갈라지고 인자가 점점 작아져 마침내 기저사례(base case, 또는 탈출지점)에 닿는다는 점에서 같다.</p>

<p>위의 그림에서 7번째 항을 구하기 위해 4번째 항이 몇 번이 계산되는가? 3번째와 2번째는? 즉, <strong>원 문제를 풀기 위한 부분문제가 너무 중복되어서 쓸데없는 시간을 잡아먹고 있는 것이다.</strong> 저런 식으로 만약 100번째 피보나치 수를 구하자고 하면 컴퓨터가 멈추고 만다.</p>

<p>대신 <strong>동적 계획법은 이미 구한 부분문제의 답을 캐쉬에 저장해서 또 구해야 할 때 바로 답을 내놓고 쓸데없는 계산을 하지 말자고 말한다.</strong> 우리는 바로 이렇게 문제를 풀 것이다.</p>

<p><br /></p>

<p>우리의 캐시는 원 문제 해결 중 마주치는 부분문제의 이항계수를 한 번 계산 후에 저장한다. <strong>캐쉬는 2차원으로 만든다.</strong> 부분문제를 계산할 때, <em>n</em> 은 0부터 <em>n</em> 까지, <em>k</em> 은 0부터 <em>k</em> 까지의 범위를 지니기 때문에 총 가능한 이항계수의 가지의 수는 <em>(n+1) * (k+1)</em> 개가 되기 때문이다. 엑셀 표를 생각하면 된다.</p>

<p><br /></p>

<p>자, <strong>캐쉬를 마련했다면 우리는 가지고 있는 2.1 번 성질을 이용해 캐쉬를 먼저 초기화한다. 그 초기화된 최소 단위의 부분문제를 조합해서 최종문제를 해결한다.</strong></p>

<p>실제 코드는 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bino_coef</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="c1"># 1.
</span>    <span class="n">cache</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># 2.
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># 3.
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">r</span><span class="p">]</span>
</code></pre></div></div>

<p><em>n</em> 개의 아이템 중 <em>r</em> 개를 뽑는 ‘bino_coef’ 함수를 만들었다. <em>k</em> 나 <em>r</em> 나 같은 의미다.</p>

<ol>
  <li>먼저 캐쉬를 만든다. 2차원에, 크기는 <em>(n+1) * (r+1)</em> 가 된다.</li>
  <li>캐쉬를 초기화한다. <strong><em>r</em> 이 0이거나, <em>n</em> 이 <em>r</em> 과 같은 경우는 2.1번 성질에 따라 그냥 1이 된다. 우리는 이 기초식을 이용해 다음 식을 계속해서 완성해나갈 것이다.</strong></li>
  <li>실제로 값을 구한다. <em>i</em> 개의 아이템 중  <em>j</em> 개의 아이템을 선택하는 경우의 수는 그보다 작은 두 값의 합이다. 이때 <em>for</em> 문을 점진적으로 전진하는 것을 기억하면 된다.</li>
</ol>

<h2 id="3-동적-계획법-2-완전탐색-memoization">3. 동적 계획법 2: 완전탐색 Memoization</h2>

<hr />

<p>위의 두 방법은 가장 일반적이며 또 실제로 유용하기도 하다. 하지만 <strong>이항계수만을 위한 함수로 확률이나 통계 등의 <code class="highlighter-rouge">확장</code>과는 거리가 있는데 지금 소개하는 방법은 확률 등으로 확장성이 매우 뛰어나다.</strong> 그래서 달달 외우라고 하고 싶은 심정이다.</p>

<p><strong>중요한 장이라 몇 개의 절로 나누어 생각한다. 먼저 이항계수를 좀더 ‘문제의 본질’의 측면에서 바라보고, 그 개념을 바탕으로 문제를 동적 계획법으로 다시 푼다. 그리고 이 방법의 장점을 설명한다음, 생각을 뒤집어 다시 한 번 구현해본다.</strong></p>

<h3 id="31-문제-다시-보기">3.1. 문제 다시 보기</h3>

<p>1번과 2번 구현은 사실 이항계수의 개념보다는 정의에 충실한 방법이다. <strong>이항계수는 개념적으로는 <em>n</em> 개의 품목 중 <em>k</em> 개의 아이템을 뽑는 조합의 수</strong>이지만 1, 2번은 개념에서 유도되는 성질만으로 문제를 해결했다. 그러니까, 내 느낌에는 저 구현들에서 <strong>뭔가 뽑는다</strong>는 생각이 직관적으로 들지 않는다.</p>

<p>이번 3번 방법은 그 과정이 실제로 ‘뽑는 작업’을 수반한다.</p>

<p><br /></p>

<p><em>n</em> 에 대해 <em>k</em> 개의 아이템을 뽑는다…는 경우의 수는 조금만 달리 생각하면 <strong>아이템을 선택할 기회가 <em>n</em> 번 있을 때 결국 <em>k</em> 개를 뽑았을 경우의 수와 일치한다.</strong> 같은 말 아닌가 하고 말할 수 있지만 <strong>후자는 각 기회가 분리될 수 있다.</strong></p>

<ul>
  <li>주어진 기회는 <em>n</em> 번이며 각 기회에서 우리가 선택할 수 있는 전략은 1. 선택하거나, 2. 선택하지 않거나 이다.</li>
  <li>우리는 0번에서 시작해서 한 번씩 선택하며, 결국 <em>n</em> 번째까지 선택했을 때 <em>k</em> 개가 선택된 경우의 수를 알고 싶다.</li>
</ul>

<p>그렇다면, <strong>0번째부터 시작해서 각 단계마다 하나를 선택하거나 선택하지 않는 방법을 모두 계산해서 최종적으로 <em>k</em> 개가 모인 경우만 세보자.</strong></p>

<hr />

<h3 id="32-구현해보기">3.2. 구현해보기</h3>

<p>2번에서도 하나의 문제가 그보다 작은 부분문제로 나뉘었다. 여기서도 문제가 나뉘지만, 그 정의가 완전히 다르다.</p>

<p><br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func(times, got) : 그동안 times만큼 기회가 있었고, 그동안 got만큼 선택했을 때, n번째에 다다랗을 때 k개를 선택하는 경우의 수
</code></pre></div></div>

<p><br /></p>

<p>위의 상황에서, <strong>결국 주어진 기회를 모두 사용했고(<em>times = n</em> 과 같고) &amp; 결과 <em>k</em> 개가 선택되었다면(<em>got = k</em>) 조합이 하나 완성되었기에 1을 반환하고, <em>k</em> 개가 완성되었다면 세면 안 되기 때문에 0을 반환한다.</strong></p>

<p>실제 코드를 확인하자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bino_coef</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># 1.
</span>    <span class="n">cache</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># 2.
</span>    <span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">got</span><span class="p">):</span>
        <span class="c1"># 3.
</span>        <span class="k">if</span> <span class="n">times</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
	    <span class="k">return</span> <span class="n">got</span> <span class="o">==</span> <span class="n">k</span>

	<span class="c1"># 4.
</span>	<span class="k">if</span> <span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">got</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
	    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">got</span><span class="p">]</span>

	<span class="c1"># 5.
</span>	<span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">got</span><span class="p">]</span> <span class="o">=</span> <span class="n">choose</span><span class="p">(</span><span class="n">times</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">got</span><span class="p">)</span> <span class="o">+</span> <span class="n">choose</span><span class="p">(</span><span class="n">times</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">got</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">got</span><span class="p">]</span>

    <span class="c1"># 6.
</span>    <span class="k">return</span> <span class="n">choose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<ol>
  <li><em>n</em> 개의 품목 중 <em>k</em> 개를 선택하는 조합의 수를 반환하는 ‘bino_coef’ 함수를 정의하고 캐쉬를 초기화한다.<br />
  여기서 눈여겨볼 것이 <strong>값을 이전과 달리 -1로 초기화하고 캐시의 크기도 <em>(n+1) * (n+1)</em> 로 키웠는데</strong> 그 이유는 잠시 뒤 확인한다.</li>
  <li>이 기회에 선택할지, 안 할지를 결정하는 <em>choose</em> 함수를 만들었다. 인자로는 그 동안의 기회를 나타내는 <em>times</em> 와, 그동안 선택한 품목의 개수인 <em>got</em> 을 받는다. 확실히 하자. <strong>이 함수의 의미는 <em>times</em> 번 동안 <em>got</em> 개를 선택하는 조합의 개수가 아니라, <em>times</em> 번까지 <em>got</em> 개를 선택했을 때, 최종적으로 <em>n</em> 번의 기회를 소진 시에 선택한 개수가 <em>k</em> 가 되는 경우의 수를 반환하는 함수이다.</strong></li>
  <li><em>n</em> 번의 선택을 마쳤다면, 함수를 종료시킨다. 이때, 그동안 선택된 개수가 문제에서 주어진 <em>k</em> 와 일치하면 <em>n</em> 개 중 <em>k</em> 를 선택했으므로 1을 반환하되, 값이 다르면 0을 반환한다.(세지 않는다)</li>
  <li>그 다음으로 캐쉬에 우리의 부분문제의 답이 저장되어 있으면 그 값을 반환한다. <strong>-1은 초기화 값으로 현재 값이 -1이라는 얘기는 이 위치의 값은 건드린 적이 없다는 것, 그러니까 이전에 계산하지 않았기 때문에 계산해야 된다는 뜻이다</strong></li>
  <li>캐쉬에 값이 없었으므로 값을 실제로 계산한다. <code class="highlighter-rouge">times 번까지 got 개를 선택했을 때, 최종적으로 n 번의 기회를 소진 시에 선택한 개수가 k 가 되는 경우의 수는 times+1 번째에 got 개가 선택되었을 때(이번에 선택하지 않았을 때)와 times+1 번째에 got+1 개가 선택된 경우의 수(이번에 선택했을 때)의 합이다.</code></li>
  <li>함수를 시작한다. 이제 시작이고 그동안 선택한 것도 없으므로 당연히 <em>times</em> 와 <em>got</em> 모두 0이 될 수밖에 없다. 함수가 계속 호출되고, 인자가 점점 커지며 결국 <em>n</em> 번째까지 이를 것이고 그때 선택한 개수가 <em>k</em> 인 경우만 합산해서 결과를 내놓는다.</li>
</ol>

<p><br /></p>

<p>이제 왜 캐쉬의 크기가 2번과 달리 더 켜졌는지와 캐쉬의 모든 초기값이 -1인지를 이해할 수 있다. <br />
<strong>2번의 경우는 우리가 선택하는 가짓수를 통제했기 때문에 <em>(n+1) * (r+1)</em> 로도 충분했지만 이번에는 컴퓨터가 <em>n</em> 번 동안 0개부터 <em>n</em> 개를 선택하는 값을 모두 만들기 때문에 캐쉬를 키워줘야 했다.</strong> 가령 <em>n</em> 개 중에 <em>n</em> 개 선택하는 조합의 수는 2번식의 캐쉬에 담을 수 없다.</p>

<p>초기값의 경우는 캐쉬의 값을 계산했는지의 여부는 0보다는 -1이 더 확실하게 파악할 수 있기 때문이다. 이항계수 문제에서 <em>k</em> 가 <em>n</em> 보다 크면 값은 무조건 0이다. 개념적으로 당연하다. <strong>그런데 캐쉬에 값이 0으로 되어 있으면 이게 계산한 값인지, 아니면 초기화된 값인지 알 수 없다. 경우의 수는 0보다 작을 수 없다. 그래서 초기값으로 -1을 선택한 것이다.</strong></p>

<p><br /></p>

<p>작은 값으로 실험을 해보자. 기회가 한 번일 때 그중 한 번 선택했을 때, 선택하지 않았을 때 모두 1로 정상적으로 나온다. <strong><em>n</em> 을 2, 3, … 등으로 키워 나가면 (0, 0)부터 시작하는 트리를 그릴 수 있다는 것을 알 수 있다.</strong> 이 트리를 한 번 그려보면 확실히 이해할 수 있다. 나도 그렇게 했다.</p>

<hr />

<h3 id="33-함수-확장하기">3.3. 함수 확장하기</h3>

<p>앞서 이 방법의 장점은 확장성이 뛰어난 것이라고 말했다. 실제로 확장해보자.</p>

<p><br /></p>

<p>지금까지의 코드는 <em>n</em> 개중 <em>k</em> 개를 선택하는 이항계수를 선택하는 코드였지만, 문제에 따라서는 ‘100개의 품목 중에서 <strong>80개 이상 선택하는 경우의 수</strong>를 구하여라’, ‘100번의 시도 끝에 <strong>5번 이하로 성공했을 경우의 수</strong>를 구하여라’와 같이 <em>k</em> 가 범위로 주어질 수도 있다.</p>

<p>이때에는 3번 코드를 한 줄만 바꿔주면 된다. 가령 최종적으로 <em>k</em> 개 이상 선택된 경우의 수는 3번 코드의 3번 부분을 살짝 손봐주면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">times</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>											<span class="c1"># 3.
</span>    <span class="k">return</span> <span class="n">got</span> <span class="o">&gt;=</span> <span class="n">k</span>
</code></pre></div></div>

<p><strong>아까는 <code class="highlighter-rouge">got == k</code>로 마지막에 선택한 개수가 <em>k</em> 개인 경우만 1을 반환했다. 이때는 <em>got</em> 이 <em>k</em> 보다 커도 0이 나왔는데 위와 같이 바꾸면서 <em>k</em> 개 이상이면 모두 1을 반환한다.</strong> 이하는 부호만 반대로 바꿔줘면 된다.</p>

<p><br /></p>

<p>또한 다음 확장은 위를 확률을 구하는 함수로도 바꿀 수 있다는 것이다. <br />
가령 이번에는 동전을 <em>n</em> 번 던질 때 앞면이 <em>k</em> 개가 나오는 <code class="highlighter-rouge">확률</code>을 계산하는 문제를 살펴보자. 이 문제는 단순한 3번식을 ‘2 ^ n’으로 나눠주면 구할 수 있지만 <strong>3번식의 5번 부분을 살짝만 바꿔줘도 구할 수 있다.</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">got</span><span class="p">]</span> <span class="o">=</span> <span class="n">choose</span><span class="p">(</span><span class="n">times</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">got</span><span class="p">)</span> <span class="o">+</span> <span class="n">choose</span><span class="p">(</span><span class="n">times</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">got</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>	<span class="c1"># 5.
</span></code></pre></div></div>

<p>원식의 5번 부분이다. 다음 단계로 함수를 진전시키는데 이를 확률로 확장하려면 각 <em>choose</em> 식 앞에 확률을 곱해주면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">got</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">choose</span><span class="p">(</span><span class="n">times</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">got</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">choose</span><span class="p">(</span><span class="n">times</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">got</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>	<span class="c1"># 5.
</span></code></pre></div></div>

<p>동전 던지는 예제라고 한다면 <strong>동전을 던져서 앞이 나오는 확률, 뒤가 나오는 확률 모두 0.5이다. 그래서 각 경우의 수에 단위확률을 곱해줌으로써 두 기대값을 구하고 더해줌으로써 확률을 구할 수 있다.</strong></p>

<p><strong>이 방법의 장점은 각 사건의 확률이 동전 던지기와 달리 동일하지 않거나, 사건의 개수가 2개가 아닌 여러 개일 때로 응용이 가능하다는 것이다.</strong> 총 확률의 합이 1이기만 하면 된다.</p>

<p>이 둘을 조합해 동전을 10번 던져 앞면이 8번 이상 나올 확률을 구하는 함수를 짜보면 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bino_coef_prob</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># 1.
</span>    <span class="n">cache</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># 2.
</span>    <span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">got</span><span class="p">):</span>
        <span class="c1"># 3.
</span>        <span class="k">if</span> <span class="n">times</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
	    <span class="k">return</span> <span class="n">got</span> <span class="o">&gt;=</span> <span class="n">k</span>

	<span class="c1"># 4.
</span>	<span class="k">if</span> <span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">got</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
	    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">got</span><span class="p">]</span>

	<span class="c1"># 5.
</span>	<span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">got</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">choose</span><span class="p">(</span><span class="n">times</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">got</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">choose</span><span class="p">(</span><span class="n">times</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">got</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">got</span><span class="p">]</span>

    <span class="c1"># 6.
</span>    <span class="k">return</span> <span class="n">choose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="o">&gt;&gt;&gt;</span> <span class="n">bino_coef_prob</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>


<span class="mf">0.0546875</span>
</code></pre></div></div>

<p><strong>정말 아름다운 일이 아닐 수 없다!</strong> 내가 이항계수 포스트를 쓰기로 한 것은 이 함수를 알게 된 것을 기록하기 위해서였다.</p>

<p>이 식은 원점부터 시작해서 양갈래로 나뉘는 트리를 그리는 것을 꼭 추천한다. 우리 식은 초기 (0, 0)부터 시작해서 올라가는 방법을 택했다. 그래서 난 Bottom-up이라고 부른다.</p>

<hr />

<h3 id="33-한-번-더-비틀기-top-down으로-구현">3.3. 한 번 더 비틀기: Top-Down으로 구현</h3>

<p>여기까지 온 거 조금 더 나아가보자. 동전을 던져서 앞면이 나왔으면 뒷면이 나오지 않은 것이고, 로또에 당첨된 것은 로또에 당첨되지 않는 것을 하지 않은 것이며, 내가 오늘 생존하면 난 오늘 죽음을 피한 것이다. 사건을 반대방향으로 시야를 뒤집어 생각하면 도움이 될 때가 많다.</p>

<p>우리의 문제는 <em>n</em> 개의 아이템 중 <em>k</em> 개의 아이템을 선택하는 것이다. 그렇다면 이 문제는 <strong>동시에 <em>n</em> 개의 아이템 중 선택하지 않는 것을 <em>n-k</em> 번 선택하는 것과 동일하다.</strong> 이는 이항계수의 성질과도 일치한다.</p>

<p>3번식은 기본적으로 제로에서 시작해 하나씩 추가해 <em>k</em> 개가 되는지 확인한다. 그래서 Bottom-up이라고 이야기했다. 그렇다면 같은 식을 개념을 살짝 뒤집어서 <strong>꽉 채운 상태에서 하나씩 빼나가면서 최종적으로 <em>n-k</em> 개가 되는지 확인하면 어떨까?</strong> 본질적으로 똑같다. 일주일 동안 커피를 마실 날을 결정하는 것은 일주일 동안 커피를 마시지 않을 날을 결정하는 것과 같으니까! 이런 접근을 Top-down 이라고 하겠다.</p>

<p>Top-down 접근방식으로 3번을 재구성하면 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bino_coef</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># 1.
</span>    <span class="n">cache</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># 2.
</span>    <span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
        <span class="c1"># 3.
</span>        <span class="k">if</span> <span class="n">times</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
	    <span class="k">return</span> <span class="n">left</span> <span class="o">==</span> <span class="mi">0</span>

	<span class="c1"># 4.
</span>	<span class="k">if</span> <span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">left</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
	    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">left</span><span class="p">]</span>

	<span class="c1"># 5.
</span>	<span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">choose</span><span class="p">(</span><span class="n">times</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">choose</span><span class="p">(</span><span class="n">times</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">times</span><span class="p">][</span><span class="n">left</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">choose</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="p">)</span>									
</code></pre></div></div>

<p>시야를 바꾼다. 이번에는 <em>times</em> 번 안에 <em>left</em>(n-k) 개를 모두 털어야 한다. 내가 기회를 쓸 때마다 기회는 줄어들고, 하나씩 털 때마다 남은 개수도 하나씩 줄기 때문에 아까와 달리 ‘-1’이 주로 사용되었다. 조금 더 비관적으로 보이기도 한다.</p>

<hr />

<h2 id="마치며">마치며</h2>

<p>이항계수를 구현하는 여러 가지 코드를 살펴보았다. 팩토리얼을 사용하는 일반적인 방법부터 동적 계획법 연습용으로 많이 쓰이는 표준 코드, 그리고 조합의 의미를 살리고 확장성이 뛰어난 다른 한 가지 방법까지. 사실 이 포스트는 세 번째 코드를 위해 작성했다.</p>

<p>언제나 문제를 푸는 방법은 단 한 가지가 아니다. 맞닥뜨린 문제에 대해 다양하게 접근하고 구현해보자. 그렇기에 3번 코드를 굳이 두 가지 방법을 같이 제시했고, 이는 아무리 생각해도 의미 있는 시도였다고 생각한다. 그리고 조금은, 철학적이기까지 한 것 같다.</p>

<p>또 어떤 알고리즘이 기다리고 있을지. 더 나은 코드를 위한 우리의 도전은 멈추지 않는다.</p>

      <div class="page-footer">
        <div class="page-share">
          <a href="https://twitter.com/intent/tweet?text=[조합론] 이항계수 알고리즘 3가지&url=http://localhost:4000/programming/algorithm/3-ways-to-get-binomial-coefficients" title="Share on Twitter" rel="nofollow" target="_blank">Twitter</a>
          <a href="https://facebook.com/sharer.php?u=http://localhost:4000/programming/algorithm/3-ways-to-get-binomial-coefficients" title="Share on Facebook" rel="nofollow" target="_blank">Facebook</a>
          <a href="https://plus.google.com/share?url=http://localhost:4000/programming/algorithm/3-ways-to-get-binomial-coefficients" title="Share on Google+" rel="nofollow" target="_blank">Google+</a>
        </div>
        <div class="page-tag">
          
            <a href="/tags#Algorithm" class="tag">&#35; Algorithm</a>
          
            <a href="/tags#binomial_coefficient" class="tag">&#35; binomial_coefficient</a>
          
        </div>
      </div>

			<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<!-- 처음과끝에만 -->
			<ins class="adsbygoogle"
					 style="display:block"
					 data-ad-client="ca-pub-2670967175857332"
					 data-ad-slot="3352812061"
					 data-ad-format="auto"
					 data-full-width-responsive="true"></ins>
			<script>
					 (adsbygoogle = window.adsbygoogle || []).push({});
			</script>
			<!-- 처음과끝에만 -->

		  <!-- Load Facebook SDK for JavaScript -->
  <div id="fb-root"></div>
  <script>(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v3.0";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));</script>

  <!-- Your share button code -->
  <div class="fb-share-button" 
    data-href="http://localhost:4000/programming/algorithm/3-ways-to-get-binomial-coefficients" 
    data-layout="button_count">
  </div>

		
    </div> <!-- End Wrap Content -->
  </div> <!-- End Page Content -->
</article> <!-- End Article Page -->

</div>

  </div>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '', 'auto');
  ga('send', 'pageview');
</script> <!-- End Analytics -->

	<script src="https://unpkg.com/simple-jekyll-search@1.5.0/dest/simple-jekyll-search.min.js"></script>
<script>
var sjs = SimpleJekyllSearch({
  searchInput: document.querySelector('#search-input'),
  resultsContainer: document.getElementById('results-container'),
  json: '/search.json',
  searchResultTemplate: '<li class="search-results-item"><a href="http://localhost:4000{url}">{title}</a></li>',
	limit: 9,
	noResultsText: '<li class="search-results-item"><a href="#">No results found...</a></li>'
})
</script>

	<!-- Main Js -->
<!--<script src="/assets/js/main.js"></script>-->

<!-- JQuery 3.x min -->
<script src="/assets/js/jquery.js"></script>

<script>
	let menus = $("#category-list");
	let image = $("#menu-toggler img");
	$("#toggler-wrapper").click(function() {
		if(menus.css("display") === "none") {
			image.attr("src", "/assets/img/close-button.png");
			menus.css("display", "flex");
		}
		else {
			image.attr("src", "/assets/img/nav-off.png");
			menus.css("display", "none");
		}
	});


</script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-127149179-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-127149179-1');
</script>

</body>
</html>
