<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>숫자 배열에서 두 번째로 큰 값 찾기 - Parkito's on the way</title>
	<!-- Mathjax Support -->

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

<!--
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
</script>
-->

<!--
<script>
MathJax = {
  tex: {
    packages: ['base', 'autoload'],        // extensions to use
    inlineMath: [              // start/end delimiter pairs for in-line math
      ['\\(', '\\)']
    ],
    displayMath: [             // start/end delimiter pairs for display math
      ['$$', '$$'],
      ['\\[', '\\]']
    ],
    processEscapes: true,      // use \$ to produce a literal dollar sign
    processEnvironments: true, // process \begin{xxx}...\end{xxx} outside math mode
    processRefs: true,         // process \ref{...} outside of math mode
    digits: /^(?:[0-9]+(?:\{,\}[0-9]{3})*(?:\.[0-9]*)?|\.[0-9]+)/,
                               // pattern for recognizing numbers
    tags: 'none',              // or 'ams' or 'all'
    tagSide: 'right',          // side for \tag macros
    tagIndent: '0.8em',        // amount to indent tags
    useLabelIds: true,         // use label name rather than tag for ids
    multlineWidth: '85%',      // width of multline environment
    maxMacros: 1000,           // maximum number of macro substitutions per expression
    maxBuffer: 5 * 1024,       // maximum size for the internal TeX string (5K)
    baseURL:                   // URL for use with links to tags (when there is a <base> tag in effect)
       (document.getElementsByTagName('base').length === 0) ?
        '' : String(document.location).replace(/#.*$/, ''),
    formatError:               // function called when TeX syntax errors occur
        (jax, err) => jax.formatError(err)
  }
};
</script>
-->

<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>



  <!-- Edit site and author settings in `_config.yml` to make the social details your own -->

    <meta content="Parkito's on the way" property="og:site_name">
  
    <meta content="숫자 배열에서 두 번째로 큰 값 찾기" property="og:title">
  
  
    <meta content="article" property="og:type">
  
  
    <meta content="숫자 배열에서 두 번째로 큰 값을 찾는 알고리즘을 살펴봅니다. 이에 그치지 않고 K번째 큰 값을 찾는 알고리즘으로까지 확장합니다." property="og:description">
  
  
    <meta content="http://localhost:4000/programming/algorithm/second-largest-number-in-array" property="og:url">
	
  
    <meta content="2019-09-11T00:00:00+09:00" property="article:published_time">
    <meta content="http://localhost:4000/about/" property="article:author">
  
  
    <meta content="http://localhost:4000/assets/img/algorithm/second-biggest-number-logo.jpg" property="og:image">
  
  
    
    <meta content="Programming" property="article:section">
    
  
  
    
    <meta content="second_largest_number" property="article:tag">
    
    <meta content="kth_largest_number" property="article:tag">
    
  

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
  
    <meta name="twitter:title" content="숫자 배열에서 두 번째로 큰 값 찾기">
  
  
    <meta name="twitter:url" content="http://localhost:4000/programming/algorithm/second-largest-number-in-array">
  
  
    <meta name="twitter:description" content="숫자 배열에서 두 번째로 큰 값을 찾는 알고리즘을 살펴봅니다. 이에 그치지 않고 K번째 큰 값을 찾는 알고리즘으로까지 확장합니다.">
  
  
    <meta name="twitter:image:src" content="http://localhost:4000/assets/img//algorithm/second-biggest-number-logo.jpg">
  

  
    <meta content="숫자 배열에서 두 번째로 큰 값을 찾는 알고리즘을 살펴봅니다. 이에 그치지 않고 K번째 큰 값을 찾는 알고리즘으로까지 확장합니다." name="description">
  
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="shortcut icon" href="/assets/img/favicon/favicon.ico" type="image/x-icon">
	<link rel="apple-touch-icon" href="/assets/img/favicon/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicon/apple-touch-icon-144x144.png">
	<!-- Chrome, Firefox OS and Opera -->
	<meta name="theme-color" content="#263959">
	<!-- Windows Phone -->
	<meta name="msapplication-navbutton-color" content="#263959">
	<!-- iOS Safari -->
	<meta name="apple-mobile-web-app-status-bar-style" content="#263959">
	<!-- Google Fonts -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=PT+Serif:400,700" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet">

	<!-- Font Awesome -->
	<link rel="stylesheet" href="/assets/fonts/font-awesome/css/font-awesome.min.css">
	<!-- Styles -->
	<link rel="stylesheet" href="/assets/css/main.css">
	<link rel="stylesheet" href="/assets/css/personal.css">
	<link href="https://fonts.googleapis.com/css?family=Do+Hyeon|Nanum+Gothic:400,700,800&amp;subset=korean" rel="stylesheet">

	<!-- googld ads tag -->
  <script data-ad-client="ca-pub-2670967175857332" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>

<body style="position: relative">
	<div id="toggler-wrapper">
		<div id="menu-toggler">
			<img src="/assets/img/nav-off.png" alt="Menu collapse image">
		</div>
	</div>

  <div class="wrapper">

		<nav id="nav">
			<div id="menus">
				<p>
					<a class="navbar-brand text-white" href="/">&nbsp;&nbsp;&nbsp;Parkito's on the way!&nbsp;&nbsp;&nbsp;</a>
				</p>
				<ul id="category-list">
					<li>
						<a href="/about.me">
							<div class="menu">
								<span> About </span>
							</div>
						</a>
					</li>
				
					<li>
						<div class="menu-wrapper">
							<a href="/category/programming">
								<div class="menu">
									<span> Programming </span>
								</div>
							</a>
							<div class="menu-item">
								<a href="/category/programming/knowledge">Knowledge</a>
								<a href="/category/programming/algorithm">Algorithm</a>
								<a href="/category/programming/python">Python</a>
								<a href="/category/programming/shell-programming">Shell programming</a>
							</div>
						</div>
					</li>
				
					<li>
						<div class="menu-wrapper">
								<a href="/category/insight">
									<div class="menu">
										<span> Insight </span>
									</div>
								</a>
								<div class="menu-item">
									<a href="/category/insight/sensitivity">&nbsp;&nbsp;Sensitivity&nbsp;&nbsp;</a>
									<a href="/category/insight/rationality">&nbsp;&nbsp;Rationality&nbsp;&nbsp;</a>
								</div>
						</div>
					</li>

					<li>
						<div class="menu-wrapper">
								<a href="/category/projects">
									<div class="menu">
										<span> Projects </span>
									</div>
								</a>
							<div class="menu-item">
								<a href="/category/projects/dev-related">&nbsp;&nbsp;Dev related&nbsp;&nbsp;</a>
								<a href="/category/projects/etc">&nbsp;&nbsp;ETC&nbsp;&nbsp;</a>
							</div>
						</div> </li>

				</ul>
			</div>

			<div id="menus-right">
				<div id="search-section">
					<div class="input-wrapper">
						<span class="fa fa-search"></span>
						<input type="text" id="search-input" placeholder="Please input specific keyword :)" size="30">
					</div>
					<div id="results-container"></div>
				</div>

				<!--<div id="toggler-wrapper">-->
					<!--<div id="menu-toggler">-->
						<!--<img src="/assets/img/nav-off.png" alt="" width="35px" height="35px">-->
					<!--</div>-->
				<!--</div>-->
				
			</div>
			
		</nav>


    <aside class="sidebar">
  <header>
    <div class="about">
      <div class="cover-author-image">
        <a href="/"><img src="/assets/img/1536558558520.jpg" alt="Sunghwan Park"></a>
      </div>
      <div class="author-name">Sunghwan Park</div>
      <p>I'm Parkito. I'm back. Obsessed with esthetics of codes, sentences, modularity and writing</p>
    </div>
  </header> <!-- End Header -->
  <footer>
    <section class="contact">
      <h3 class="contact-title">Contact me</h3>
      <ul>
				<!--
        
          <li><a href="https://twitter.com/artemsheludko_" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
        
        
          <li><a href="https://facebook.com/" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a></li>
        
				-->
        
          <li class="github"><a href="http://github.com/shoark7" target="_blank"><i class="fa fa-github"></i></a></li>
        
        
          <li class="linkedin"><a href="https://in.linkedin.com/in/sunghwan-park-3773b8154" target="_blank"><i class="fa fa-linkedin"></i></a></li>
        
        
          <li class="email"><a href="mailto:shoark7@gmail.com"><i class="fa fa-envelope-o"></i></a></li>
        
      </ul>
    </section> <!-- End Section Contact -->
    <div class="copyright">
      <p>2023 &copy; Sunghwan Park</p>
    </div>
  </footer> <!-- End Footer -->
</aside> <!-- End Sidebar -->

<div class="content-box clearfix">
  <article class="article-page">
  <div class="page-content">
    
    <div class="page-cover-image">
      <figure>
        <img class="page-image" src=/assets/img//algorithm/second-biggest-number-logo.jpg alt="숫자 배열에서 두 번째로 큰 값 찾기">
        
      </figure>
    </div> <!-- End Page Cover Image -->
    
    <div class="wrap-content">
      <header class="header-page">
        <h1 class="page-title">숫자 배열에서 두 번째로 큰 값 찾기</h1>
        <div class="page-date"><span>2019, Sep 11&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
      </header>

		<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
		<!-- 처음과끝에만 -->
		<ins class="adsbygoogle"
				 style="display:block"
				 data-ad-client="ca-pub-2670967175857332"
				 data-ad-slot="3352812061"
				 data-ad-format="auto"
				 data-full-width-responsive="true"></ins>
		<script>
				 (adsbygoogle = window.adsbygoogle || []).push({});
		</script>
		<!-- 처음과끝에만 -->

      <h2 id="0-index">0. Index</h2>

<blockquote>
  <ol>
    <li><a href="#1">들어가며</a></li>
    <li><a href="#2">Way 1: 정렬하기</a></li>
    <li><a href="#3">Way 2: for문 한 번에 끝내기</a></li>
    <li><a href="#4">그게 최선입니까? 확실해요?</a>
      <ul>
        <li>4.1. <a href="#4a">확장의 여지</a></li>
        <li>4.2. <a href="#4b">핵심 아이디어: 삽입정렬</a></li>
        <li>4.3. <a href="#4c">실제 코드</a></li>
        <li>4.4. <a href="#4d">시간복잡도 비교</a></li>
      </ul>
    </li>
    <li><a href="#5">마치며</a></li>
  </ol>
</blockquote>

<p><br id="1" /></p>

<h2 id="1-들어가며">1. 들어가며</h2>

<hr />

<p>재미있는 알고리즘 문제를 들고 왔다. 바로 <strong>숫자 배열에서 두 번째로 큰 값 찾기.</strong> 파이썬에서 배열의 최대값을 찾는 것은 매우 간단하다. 누구나 알 듯이 <code class="language-plaintext highlighter-rouge">max</code> 함수를 쓰면 되는데, 그러면 두 번째로 큰 값은 어떻게 찾을까? 딱히 생각을 하지 않으면 그 누구도 이런 질문을 하지 않는다. 1등만 기억하는 더러운 세상.</p>

<p>문제가 너무 직관적이고 쉬워서 따로 ‘문제 소개’ 장은 넣지 않고 바로 알고리즘으로 넘어간다. 두 번째로 큰 값을 찾는 알고리즘을 두 개 가져왔다. 하나는 너무 쉽고, 다른 하나는 약간의 사고를 해야 한다. 후자의 방법이 시간복잡도가 더 좋기 때문에 기억할만한 가치가 있다.</p>

<p>그 다음 여기서 끝내기에는 뭔가 아쉽다. 그래서 문제를 확장해서 생각하고 핵심 아이디어를 도출해 더 범용적인 기능을 만들어보는 것까지 진행해본다.</p>

<p>아 참고로, <strong>내 코드에서는 값이 중복되어 같은 경우는 포함하지 않는다. 예를 들어 <em>[2, 2, 1]</em> 에서 중복을 허용하면 두 번째로 큰 값은 2가 되지만 우리는 허용하지 않는다. 따라서 답은 1이 된다.</strong></p>

<p><br />
<br id="2" /></p>

<h2 id="2-way-1-정렬하기">2. Way 1: 정렬하기</h2>

<hr />

<p>가장 쉬운 방법은 역시 <code class="language-plaintext highlighter-rouge">정렬</code>을 통한 방법이다. <strong>배열을 내림차순 정렬하고 두 번째로 발견되는 고유한 값을 반환하면 그대로 된다.</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">second_largest_number</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">unique_nums</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">sorted_nums</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">unique_nums</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sorted_nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>배열의 두 번째 큰 값인 <em>second_largest_number</em> 함수를 정의했다. 이때 <em>set</em> 을 통해 정렬 전에 고유한 값만 남기는 작업을 첫째 줄에서 진행하는데 우리는 중복을 허용하지 않기 때문에 이 작업을 거쳐야 한다. 그후 내림차순 정렬하고, 2번째 값을 반환하면 된다.</p>

<p>무식하게 쉬운데 이건 맛보기다. <strong>시간복잡도는 정렬을 사용하기 때문에 \(O(N log N)\)이 된다.</strong></p>

<p><br />
<br id="3" /></p>

<h2 id="3-way-2-for문-한-번에-끝내기">3. Way 2: for문 한 번에 끝내기</h2>

<hr />

<p>이 방법이 아마 이 포스트를 읽는 사람들이 만족해하지 않을까 싶다. 앞선 정렬방법은 시간복잡도가 \(O(N log N)\)였는데, 좀 더 잘한다면 반복문 한 번으로 끝낼 수 있다.</p>

<p><strong>핵심은 최대값과 두 번째 큰 값을 추적하는 변수를 두고, 배열의 각 값을 순회하며 두 변수를 갱신하는 것이다.</strong> 알고리즘이 어렵지는 않기 때문에 바로 코드를 확인하자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">second_largest_number</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">second</span> <span class="o">=</span> <span class="n">largest</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span> 
    
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">largest</span><span class="p">:</span>
            <span class="n">second</span> <span class="o">=</span> <span class="n">largest</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">elif</span> <span class="n">second</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">largest</span><span class="p">:</span>
            <span class="n">second</span> <span class="o">=</span> <span class="n">n</span>

    <span class="k">return</span> <span class="n">second</span>
</code></pre></div></div>

<p>앞선 함수와 같은 이름의 함수지만 이번에는 반복문 한 번에 해결할 수 있었다. 중요한 각 부분을 설명하면 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">second</span> <span class="o">=</span> <span class="n">largest</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span> 
</code></pre></div></div>

<p><strong>최대값과 두 번째 큰 값을 추적할 변수 <em>largest</em>, <em>second</em> 변수를 음의 무한으로 초기화한다.</strong> 이 값을 음의 무한대로 초기화한 것은 중요한 의미가 있는데, 우리는 for 반복문을 돌면서 두 변수를 점차 큰 값으로 깎아 나갈 것이기 때문에 그를 위해서는 값을 가장 작은 값으로 만들어놔야 한다. 종종 충분히 작은 값으로 초기화해야 할 때 <code class="language-plaintext highlighter-rouge">-99999999</code>, 이런 식의 값을 쓰는 경우가 있는데 이런 경우는 피해야 한다. 배열의 최대값이 저 은하철도 999 숫자보다 작은 경우가 얼마든지 있을 수 있으니까.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">largest</span><span class="p">:</span>
        <span class="n">second</span> <span class="o">=</span> <span class="n">largest</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">elif</span> <span class="n">second</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">largest</span><span class="p">:</span>
        <span class="n">second</span> <span class="o">=</span> <span class="n">n</span>
</code></pre></div></div>

<p>다음은 실제로 반복문을 돌면서 두 번째로 큰 값을 만들어나가는 과정이다. 현재 순회하는 배열의 값 <em>n</em> 에 대해 우리가 생각해봐야 할 케이스는 3가지다.</p>

<ol>
  <li><strong>현재 최대값(<em>largest</em>)보다 클 경우:</strong>
    <ul>
      <li><strong>최대값과 두 번째 큰 값 모두 경신하면 된다. 먼저 두 번째 값을 이전 최대값으로 재설정하고, 최대값에 <em>n</em> 을 둔다.</strong></li>
    </ul>
  </li>
  <li><strong>두 번째 큰 값보다 크고 최대값보다 작은 경우:</strong>
    <ul>
      <li><strong>두 번째 값(<em>second</em>)만 경신하면 된다.</strong></li>
    </ul>
  </li>
  <li>그 외:
    <ul>
      <li>무시한다. 난 나보다 약한 상대의 말 따위는 듣지 않는다.</li>
    </ul>
  </li>
</ol>

<p>저 반복문 코드는 정확히 이 세 상황에 대응한다.</p>

<p><br /></p>

<p><strong>이 코드는 \(O(N)\)의 준수한 시간복잡도로 문제를 정확하게 해결하며 정렬 코드에 비해 그렇게 복잡하지도 않다.</strong> 그래서 이 문제에 대한 더 바람직한 해결책이라고 할 수 있겠다. 우리는 이제 2등도 기억할 수 있게 됐다.</p>

<p>이상 포스트를 마칩니다.</p>

<p><br />
<br id="4" /></p>

<h2 id="4-그게-최선입니까-확실해요">4. 그게 최선입니까? 확실해요?</h2>

<hr />

<p>물론! 겨우 이 정도로 끝나지 않았다. 겨우 이 정도의 분량과 인사이트를 가진 포스트를 내가 굳이 만들지는 않으니까. 이 포스트를 만든 이유에 대한 구현은 지금부터다.</p>

<p>이번 문제는 숫자 배열에서 <strong>두 번째</strong>로 큰 고유한 값을 찾는 것이었다. 하지만 이 정도에 만족하면 성장하지 않는다. 더 생각해볼 것은 없을까?</p>

<p><br id="4a" /></p>

<h3 id="41-확장의-여지">4.1. 확장의 여지</h3>

<p>항상 이야기하지만 <code class="language-plaintext highlighter-rouge">좋은 프로그램이란 무엇인가</code>란 질문을 끊임없이 해야 한다. 이 질문은 정말 어려운 질문이지만, 이 두 명제는 많은 경우 참인 것 같다.</p>

<pre class="function-definition">
1. 좋은 프로그램은 많은 사람들이 쓰는 프로그램이다.
2. 많은 사람들이 쓰면 좋은 프로그램이 된다.
</pre>

<p>꼬리에 꼬리를 무는 느낌인데 이 두 명제는 서로 상호보완적이다. 좋은 프로그램은 당연히 그렇지 않은 프로그램보다 많은 사람들이 쓸테고, 또 많은 사람들이 쓰다보면 사용자 정보 축적 등 다양한 이유로 더 좋은 프로그램이 될 수 있다. 카카오톡이 라인보다 정말 압도적으로 우월해서 다수의 대한민국 국민들이 일상 메신저로 쓰는걸까? 난 아니라고 본다.</p>

<p><br /></p>

<p>돌아와서, 좋은 프로그램은 많은 사람들이 쓰는 프로그램이다. 이때 분명히 해야 할 것은 사용자마다의 요구사항이나 수요가 다 다를 것이라는 것이다. 다시 말해 <strong>좋은 프로그램은 다양한 수요와 니즈를 갖춘 사용자를 모두 만족시킬 수 있는 프로그램을 말한다.</strong></p>

<p>이때 우리 프로그램은 좋은 프로그램일까? 우리 프로그램의 문제의식은 배열의 최대값이 아닌 두 번째로 큰 값을 찾는 것이다. 그러면 경우에 따라선 <strong>세 번째 값이나 네 번째 값, 100번째 큰 값을 원하는 사람은 정말 없을까???</strong> 두 번째 큰 값을 찾는 사람뿐 아니라 다른 사람들의 수요도 만족시킬 수 있다면, 보다 <code class="language-plaintext highlighter-rouge">범용적</code>인 프로그램이라면 더 많은 사용자를 만족시킬 수 있고, 더 좋은 프로그램일 것이다.</p>

<p>따라서 단순히 이 문제를 구현함을 넘어 우리는 확장의 여지를 본다.</p>

<p class="function-definition">
숫자 배열에서 K번째로 큰 고유한 값을 찾아라
</p>

<p><strong>우리의 문제는 보다 일반적이 되었으며 문제를 해결해 탄생하는 기능은 아마 더 범용적인 기능이 될 것이다.</strong></p>

<p><br id="4b" /></p>

<h3 id="42-핵심-아이디어-삽입정렬">4.2. 핵심 아이디어: 삽입정렬</h3>

<p>좋다. 확장된 문제를 구현하자. 어떻게 해야 할까? 우리는 포스트에서 두 가지 방법을 살폈는데 먼저 정렬의 경우 이 문제를 구현하는 것은 매우 쉽다. <strong>원 코드에서는 반환값에서 두 번째를 의미하는 <code class="language-plaintext highlighter-rouge">1</code>을 인덱스로 했는데 그 대신 새로 받은 <code class="language-plaintext highlighter-rouge">K-1</code>번째 값을 반환하면 된다.</strong> 코드는 대략 이렇게 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">kth_largest_number</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="n">unique_nums</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">sorted_nums</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">unique_nums</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sorted_nums</span><span class="p">[</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>함수의 이름의 접두사를 <em>second</em> 가 아닌 <code class="language-plaintext highlighter-rouge">K번째</code>를 의미하는 <em>kth</em> 로 변경했다. 그리고 사용자가 원하는 순서를 뜻하는 <em>K</em> 인자를 받는다. 코드는 두 번째 큰 값을 찾던 원래 코드와 거의 일치하며, 반환할 때만 인덱스를 <em>K-1</em> 로 하면 된다.</p>

<p><br /></p>

<p>정렬의 경우는 쉬웠는데 두 번째 알고리즘은 까다롭다. 가령 K가 100이라고 해보자. 어떻게 100번째 값을 저장해야 하는가. 원 코드를 참조해 첫 번째, 두 번째, 세 번째, …, 100번째 큰 값을 담는 100개의 변수를 설정해야 할까?</p>

<p><strong>이 경우에는 배열에 최대값부터 K번째까지의 값을 저장하는 것이 바람직해보인다.</strong> 애초에 그럴 용도로 배열을 쓰는거니까. 이 방법이 K개의 줄에 변수 할당식을 쓰는 방법보다 훨신 유용해보인다. 이 포스트에서는 이 용도의 배열을 <code class="language-plaintext highlighter-rouge">memory</code>라고 표현하겠다.</p>

<p><br /></p>

<p>그 다음으로, 반복문의 한 번의 순회에서 어떻게 if 문을 써나가야 할까? 아까 K가 2개인 경우에 우리가 상정해야 할 케이스가 3가지였다. 그러면 K에 대해서는 K+1 가지의 케이스를 고려해야 한다는 것인데.</p>

<p><strong>이 경우에도 memory를 반복문으로 순회하며 새로운 값을 뒤집어써야 할 경우에 값을 재설정하면 될 것 같다.</strong></p>

<p><br /></p>

<p>마지막으로 하나 더 고려해야 한다. 원 배열을 순회할 때 K개의 값을 갖는 memory에 첫 번째부터 K번째 큰 값까지 유지·변경할텐데 이 과정을 어떻게 해야 할까? 가령 K가 5고 배열 순회 중 세 번째 큰 값보다 큰 새로운 값을 찾았을 때 어떻게 이를 기록할까?</p>

<p><img src="/assets/img/algorithm/kth_largest_numbers.png" alt="how_to_insert_kth_largest" /></p>

<p>힌트는 아까 만든 두 번째 큰 값을 찾는 코드의 비교 부분을 보면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">largest</span><span class="p">:</span>
            <span class="n">second</span> <span class="o">=</span> <span class="n">largest</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">n</span>
</code></pre></div></div>

<p>정확히 필요한 부분만 가져왔다. 만약 지금 순회하는 배열의 값 <em>n</em> 이 가장 큰 값(<em>largest</em>)보다 클 경우 <em>largest</em> 를 바로 <em>n</em> 으로 할당하는 것이 아니라, <strong>두 번째 값을 <em>largest</em> 으로 재설정한 뒤, <em>largest</em> 값을 <em>n</em> 으로 뒀다.</strong></p>

<p>이것을 현재 문제로 확장하면 <strong>현재 배열의 값(<em>n</em>)보다 작은 값을 찾으면 그 뒤의 원소들을 모두 한 번씩 뒤로 물린 뒤에 그 위치에 <em>n</em> 을 두는 것이 핵심이다.</strong></p>

<p><img src="/assets/img/algorithm/kth_largest_numbers_inserted.png" alt="inserted numbers" /></p>

<p>이는 흡사 <code class="language-plaintext highlighter-rouge">삽입정렬</code>(insertion sort)을 연상시킨다. 삽입정렬에서도 오름차순일 때 현재 값보다 작은 값을 찾으면 뒤의 나머지 값을 모두 하나씩 뒤로 미룬 뒤에 값을 할당했으니까. 이제 이 핵심개념을 토대로 실제 코드를 작성해보자.</p>

<p><br id="4c" /></p>

<h3 id="43-실제-코드">4.3. 실제 코드</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">kth_biggest</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="s">"""숫자 배열에서 K번째로 큰 값을 구한다.

    이 함수는 고유한 값을 대상으로 한다.
    가령 [2, 2, 1]에서 2번째로 큰 값은 2가 아닌 1이다.

    또한 K가 배열의 고유한 값들의 개수보다 크면 IndexError를 반환한다.

    :input:
      arr | list := 숫자 배열
      K   | int  := 1 이상의 정수를 대상으로 한다.

    :return:
      int := 배열에서 K번째로 큰 값
    """</span>
    <span class="c1"># 예외 처리: K는 배열의 고유한 값 개수보다 클 수 없다.
</span>    <span class="n">ORDINAL_MSG</span> <span class="o">=</span> <span class="p">(</span><span class="s">'st'</span><span class="p">,</span> <span class="s">'nd'</span><span class="p">,</span> <span class="s">'rd'</span><span class="p">)[</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">K</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="k">else</span> <span class="s">'th'</span>
    <span class="n">unique_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_set</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s">"There's no </span><span class="si">{</span><span class="n">K</span><span class="si">}{</span><span class="n">ORDINAL_MSG</span><span class="si">}</span><span class="s"> value in array"</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">K</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">"K should be over 0 and arr should not be empty"</span><span class="p">)</span>


    <span class="c1"># 상수 및 변수 선언
</span>    <span class="n">INF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>
    <span class="n">memory</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">INF</span><span class="p">]</span> <span class="o">*</span> <span class="n">K</span>


    <span class="c1"># 실제 검색 연산
</span>    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">memory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">memory</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">memory</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">memory</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">memory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>실제 코드를 만들었다. 이 부분이 이 포스트에서 제일 중요해서 docstring과 에러체크하는 부분까지 다 넣어 완전한 기능으로 완성했는데 중요한 각 부분을 확인하면 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 예외 처리: K는 배열의 고유한 값 개수보다 클 수 없다.
</span><span class="n">ORDINAL_MSG</span> <span class="o">=</span> <span class="p">(</span><span class="s">'st'</span><span class="p">,</span> <span class="s">'nd'</span><span class="p">,</span> <span class="s">'rd'</span><span class="p">)[</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">K</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="k">else</span> <span class="s">'th'</span>
<span class="n">unique_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_set</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">:</span>
    <span class="k">raise</span> <span class="nb">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s">"There's no </span><span class="si">{</span><span class="n">K</span><span class="si">}{</span><span class="n">ORDINAL_MSG</span><span class="si">}</span><span class="s"> value in array"</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">K</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">arr</span><span class="p">:</span>
    <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">"K should be over 0 and arr should not be empty"</span><span class="p">)</span>
</code></pre></div></div>

<p>실제 코드를 작성하기 전에 <em>arr</em>, <em>K</em> 가 올바른 값인지 확인하는 과정을 거쳤다. 정상적으로 기능이 작동하기 위해서는 <em>arr</em> 은 비어있으면 안 되고, <em>K</em> 는 1 이상의 정수여야 하며, <em>arr</em> 의 고유한 값의 개수(데이터베이스 용어로는 ‘cardinality’)보다 커서는 안 된다. 이 조건을 검증했다.</p>

<p>주석 바로 위의 줄은 개인적인 욕심으로 적었는데 고유한 값의 개수가 <em>K</em> 보다 작을 경우 “There’s no 1st value..” 와 같은 메시지를 넣고 싶었다. 그런데 서수 표현에서 숫자에 따라 뒤에 붙는 기호가 ‘st’, ‘nd’, ‘rd’, ‘th’와 같이 변하기 때문에 이를 위한 코드를 넣었다. 중요하지는 않으니 넘어가자.</p>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 상수 및 변수 선언
</span><span class="n">INF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>
<span class="n">memory</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">INF</span><span class="p">]</span> <span class="o">*</span> <span class="n">K</span>
</code></pre></div></div>

<p>첫 번째부터 K번째 큰 값까지 저장할 <em>memory</em> 를 선언했다. 크기는 당연히 <em>K</em> 인데, 각 값을 음의 무한대로 초기화한 것을 눈여겨볼만하다. 여기에는 최대값 이하 숫자들이 들어갈 것이기 때문에 가급적 최소값으로 해놓으면 무리없이 각 원소가 채워질 것이다.</p>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">memory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">continue</span>
</code></pre></div></div>

<p>배열의 원소마다 순회한다. 각 숫자로 실질적인 알고리즘을 진행하기 전에 먼저 이 숫자와 현재 <em>memory</em> 의 K번째 값과의 대소관계를 비교한다. 이 이유는 현재 <em>n</em> 이 지금까지의 memory의 최소값보다 작거나 같으면 밑에 중첩된 반복문 자체를 실행하지 않아도 되기 때문이다. 따라서 이 경우에는 <em>continue</em> 로 건너 뛴다. 이제 핵심 부분으로 넘어가자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">memory</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">memory</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">memory</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">memory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p><em>n</em> 과 memory의 각 값을 비교하기 위해 for 문을 중첩했다. 이때 <em>n</em> 과 현재 비교하는 <em>memory</em> 의 값을 <em>m</em> 이라고 할 때, <em>n</em> 이 <em>memory</em> 에 들어오기 위해서는 <strong><em>n</em> 은 <em>m</em> 보다 커야하고 <em>m</em> 의 바로 앞의 값보다는 작아야 한다.</strong> 그 검증을 if 문에서 하고 있다. 단, <em>m</em> 이 첫 번째 원소라면 <em>m</em> 의 바로 앞의 값은 없기 때문에 i가 0일 때는 따로 검증해 <code class="language-plaintext highlighter-rouge">or</code>로 묶는다. 이렇게 하지 않으면 <em>memory[i-1]</em> 부분에서 ‘-1’이라는 엉뚱한 인덱스가 튀어나올 수 있다.</p>

<p>만약 조건식에서 True가 반환된다면, 다시 말해 <em>n</em> 이 값을 뒤집어써야 할 <em>m</em> 과 그 위치를 찾았다면 다시 한 번 반복문을 실행한다. 값을 하나씩 뒤로 밀어야하기 때문이다. 이때 현재 <em>m</em> 의 위치 <em>i</em> 가 아니라 <strong>맨 뒤에서부터 거꾸로 앞의 값을 현재 위치로 뒤집어써야 한다는 것을 명심하자.</strong> 두 번째 큰 값을 찾는 코드에서도 <em>n</em> 이 <em>largest</em> 보다 클 때 <em>largest</em> 보다 <em>second</em> 변수가 먼저 재설정됐다는 것을 보면 납득할 수 있다.</p>

<p>현재 <em>m</em> 의 위치 <em>i</em> 의 바로 뒤까지 값이 밀렸으면 이제 <em>i</em> 에 <em>n</em> 을 할당한다. 그러면 현재까지의 최대값이 경신된다.</p>

<p>반복문을 완전히 탈출한 뒤에 memory의 마지막 값이 K번째 최대값이기 때문에 이를 반환하면 된다.</p>

<p><br id="4d" /></p>

<h3 id="44-시간복잡도-비교">4.4. 시간복잡도 비교</h3>

<p>두 코드의 시간복잡도는 어떻게 될까? 일단 정렬코드는 여전히 \(O(N log N)\)이다. 문제는 뒤의 코드인데 두 번째 큰 값을 찾을 때는 \(O(N)\)이라고 할 수 있었으나 지금은 다르다. K의 값이 미지수이기 때문이다. <strong>복잡도는 for문을 보면 이해할 수 있는데 원 배열(\(N\))에서 memory와 관련된 두 번의 for문이 연속적으로 중첩된다. 따라서 이 코드의 복잡도는 \(O(N * K^2)\)가 된다.</strong></p>

<p>생각보다 복잡도가 높아서 이 코드가 정렬보다 무조건 좋다고는 말할 수 없다. K가 2, 3과 같이 충분히 작다면 효율적이겠지만 가령 1000번째 큰 수를 찾는다고 하면 매우 복잡해진다.</p>

<p>사실은 포스트를 기획했을 때는 대충 계산해서 복잡도를 \(O(N * K)\)로 추정했다. 하지만 지금 보니 아니여서 조금 당황했는데 그래도 K가 (충분히) 작을 때는 유의미하다고 생각한다. 문제상황에 맞게 필요한 방법을 사용하면 되겠다.</p>

<p><br />
<br id="5" /></p>

<h2 id="5-마치며">5. 마치며</h2>

<hr />

<p>현재 나는 초심자분들과 알고리즘 스터디를 하며 그분들의 코드에 리뷰를 많이 한다. 이 문제도 같이 풀고 코드를 받았는데, 이 문제에 대해 가장 쉬운 접근법으로 풀지 않는 분들이 꽤 있다. 역시 처음엔 다 어려운 법이다. 그런 의미에서 이 문제를 포스트 주제로 잡은 것은 나쁜 선택은 아닌 것 같다.</p>

<p>다만 다루는 문제가 점점 쉬워지는 것은 아닌가 하는 생각도 들기는 하는데 결국 중요한 것은 내 컨셉인 것 같다. 내 알고리즘 포스트의 핵심컨셉은 <code class="language-plaintext highlighter-rouge">한 문제를 위한 알고리즘은 여러 가지일 수 있다</code>이기 때문에 이를 증명하는 다양한 수준과 복잡도의 알고리즘을 제시하는 것이 중요하겠다.</p>

<p>다음엔 어떤 포스트를 해야 할까? 벌써부터 마감의 압박이 느껴진다.</p>

<p>이상 포스트를 마칩니다.</p>

      <div class="page-footer">
        <div class="page-share">
          <a href="https://twitter.com/intent/tweet?text=숫자 배열에서 두 번째로 큰 값 찾기&url=http://localhost:4000/programming/algorithm/second-largest-number-in-array" title="Share on Twitter" rel="nofollow" target="_blank">Twitter</a>
          <a href="https://facebook.com/sharer.php?u=http://localhost:4000/programming/algorithm/second-largest-number-in-array" title="Share on Facebook" rel="nofollow" target="_blank">Facebook</a>
          <a href="https://plus.google.com/share?url=http://localhost:4000/programming/algorithm/second-largest-number-in-array" title="Share on Google+" rel="nofollow" target="_blank">Google+</a>
        </div>
        <div class="page-tag">
          
            <a href="/tags#second_largest_number" class="tag">&#35; second_largest_number</a>
          
            <a href="/tags#kth_largest_number" class="tag">&#35; kth_largest_number</a>
          
        </div>
      </div>

			<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
			<!-- 처음과끝에만 -->
			<ins class="adsbygoogle"
					 style="display:block"
					 data-ad-client="ca-pub-2670967175857332"
					 data-ad-slot="3352812061"
					 data-ad-format="auto"
					 data-full-width-responsive="true"></ins>
			<script>
					 (adsbygoogle = window.adsbygoogle || []).push({});
			</script>
			<!-- 처음과끝에만 -->

		  <!-- Load Facebook SDK for JavaScript -->
  <div id="fb-root"></div>
  <script>(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v3.0";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));</script>

  <!-- Your share button code -->
  <div class="fb-share-button" 
    data-href="http://localhost:4000/programming/algorithm/second-largest-number-in-array" 
    data-layout="button_count">
  </div>

		
    </div> <!-- End Wrap Content -->
  </div> <!-- End Page Content -->
</article> <!-- End Article Page -->

</div>

  </div>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '', 'auto');
  ga('send', 'pageview');
</script> <!-- End Analytics -->

	<script src="https://unpkg.com/simple-jekyll-search@1.5.0/dest/simple-jekyll-search.min.js"></script>
<script>
var sjs = SimpleJekyllSearch({
  searchInput: document.querySelector('#search-input'),
  resultsContainer: document.getElementById('results-container'),
  json: '/search.json',
  searchResultTemplate: '<li class="search-results-item"><a href="http://localhost:4000{url}">{title}</a></li>',
	limit: 9,
	noResultsText: '<li class="search-results-item"><a href="#">No results found...</a></li>'
})
</script>

	<!-- Main Js -->
<!--<script src="/assets/js/main.js"></script>-->

<!-- JQuery 3.x min -->
<script src="/assets/js/jquery.js"></script>

<script>
	let menus = $("#category-list");
	let image = $("#menu-toggler img");
	$("#toggler-wrapper").click(function() {
		if(menus.css("display") === "none") {
			image.attr("src", "/assets/img/close-button.png");
			menus.css("display", "flex");
		}
		else {
			image.attr("src", "/assets/img/nav-off.png");
			menus.css("display", "none");
		}
	});


</script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-127149179-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-127149179-1');
</script>

</body>
</html>
