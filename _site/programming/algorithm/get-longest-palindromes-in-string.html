<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>[Python] Get longest palindromes in string - Parkito's on the way</title>

  <!-- Edit site and author settings in `_config.yml` to make the social details your own -->

    <meta content="Parkito's on the way" property="og:site_name">
  
    <meta content="[Python] Get longest palindromes in string" property="og:title">
  
  
    <meta content="article" property="og:type">
  
  
    <meta content="We get longest palindromes in a with a bad and a good solution in Python" property="og:description">
  
  
    <meta content="https://shoark7.github.io/programming/algorithm/get-longest-palindromes-in-string" property="og:url">
	
  
    <meta content="2019-04-16T00:00:00+09:00" property="article:published_time">
    <meta content="https://shoark7.github.io/about/" property="article:author">
  
  
    <meta content="https://shoark7.github.io/assets/img/algorithm/longest-palindromes-logo.png" property="og:image">
  
  
    
    <meta content="Programming" property="article:section">
    
  
  
    
    <meta content="Palindrome" property="article:tag">
    
    <meta content="Dynamic_programming" property="article:tag">
    
  

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
  
    <meta name="twitter:title" content="[Python] Get longest palindromes in string">
  
  
    <meta name="twitter:url" content="https://shoark7.github.io/programming/algorithm/get-longest-palindromes-in-string">
  
  
    <meta name="twitter:description" content="We get longest palindromes in a with a bad and a good solution in Python">
  
  
    <meta name="twitter:image:src" content="https://shoark7.github.io/assets/img//algorithm/longest-palindromes-logo.png">
  

  
    <meta content="We get longest palindromes in a with a bad and a good solution in Python" name="description">
  
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="shortcut icon" href="/assets/img/favicon/favicon.ico" type="image/x-icon">
	<link rel="apple-touch-icon" href="/assets/img/favicon/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicon/apple-touch-icon-144x144.png">
	<!-- Chrome, Firefox OS and Opera -->
	<meta name="theme-color" content="#263959">
	<!-- Windows Phone -->
	<meta name="msapplication-navbutton-color" content="#263959">
	<!-- iOS Safari -->
	<meta name="apple-mobile-web-app-status-bar-style" content="#263959">
	<!-- Google Fonts -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=PT+Serif:400,700" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet">

	<!-- Font Awesome -->
	<link rel="stylesheet" href="/assets/fonts/font-awesome/css/font-awesome.min.css">
	<!-- Styles -->
	<!-- Mathjax Support -->
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
	MathJax.Hub.Config({
  showProcessingMessages: false,
  jax: ["input/TeX", "output/HTML-CSS"],
  TeX: {
    TagSide: "left",
    Macros: {
      RR: '{\\bf R}',
      bold: ['{\\bf #1}',1]
    }
  },
  CommonHTML: {
    linebreaks: {automatic: true}
  }
});
</script>

	<link rel="stylesheet" href="/assets/css/main.css">
	<link rel="stylesheet" href="/assets/css/personal.css">
	<link href="https://fonts.googleapis.com/css?family=Do+Hyeon|Nanum+Gothic:400,700,800&amp;subset=korean" rel="stylesheet">

	<!-- googld ads tag -->
  <script data-ad-client="ca-pub-2670967175857332" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>

<body style="position: relative">
	<div id="toggler-wrapper">
		<div id="menu-toggler">
			<img src="/assets/img/nav-off.png" alt="Menu collapse image">
		</div>
	</div>

  <div class="wrapper">

		<nav id="nav">
			<div id="menus">
				<p>
					<a class="navbar-brand text-white" href="/">&nbsp;&nbsp;&nbsp;Parkito's on the way!&nbsp;&nbsp;&nbsp;</a>
				</p>
				<ul id="category-list">
					<li>
						<a href="/about.me">
							<div class="menu">
								<span> About </span>
							</div>
						</a>
					</li>
				
					<li>
						<div class="menu-wrapper">
							<a href="/category/programming">
								<div class="menu">
									<span> Programming </span>
								</div>
							</a>
							<div class="menu-item">
								<a href="/category/programming/knowledge">Knowledge</a>
								<a href="/category/programming/algorithm">Algorithm</a>
								<a href="/category/programming/python">Python</a>
								<a href="/category/programming/shell-programming">Shell programming</a>
							</div>
						</div>
					</li>
				
					<li>
						<div class="menu-wrapper">
								<a href="/category/insight">
									<div class="menu">
										<span> Insight </span>
									</div>
								</a>
								<div class="menu-item">
									<a href="/category/insight/sensitivity">&nbsp;&nbsp;Sensitivity&nbsp;&nbsp;</a>
									<a href="/category/insight/rationality">&nbsp;&nbsp;Rationality&nbsp;&nbsp;</a>
								</div>
						</div>
					</li>

					<li>
						<div class="menu-wrapper">
								<a href="/category/projects">
									<div class="menu">
										<span> Projects </span>
									</div>
								</a>
							<div class="menu-item">
								<a href="/category/projects/dev-related">&nbsp;&nbsp;Dev related&nbsp;&nbsp;</a>
								<a href="/category/projects/etc">&nbsp;&nbsp;ETC&nbsp;&nbsp;</a>
							</div>
						</div> </li>

				</ul>
			</div>

			<div id="menus-right">
				<div id="search-section">
					<div class="input-wrapper">
						<span class="fa fa-search"></span>
						<input type="text" id="search-input" placeholder="Please input specific keyword :)" size="30">
					</div>
					<div id="results-container"></div>
				</div>

				<!--<div id="toggler-wrapper">-->
					<!--<div id="menu-toggler">-->
						<!--<img src="/assets/img/nav-off.png" alt="" width="35px" height="35px">-->
					<!--</div>-->
				<!--</div>-->
				
			</div>
			
		</nav>


    <aside class="sidebar">
  <header>
    <div class="about">
      <div class="cover-author-image">
        <a href="/"><img src="/assets/img/1536558558520.jpg" alt="Sunghwan Park"></a>
      </div>
      <div class="author-name">Sunghwan Park</div>
      <p>I'm Parkito. A Python lover. Interested in Python, Automation, Algorithm. Please give me insights. I'll teach you tambien! :)</p>
    </div>
  </header> <!-- End Header -->
  <footer>
    <section class="contact">
      <h3 class="contact-title">Contact me</h3>
      <ul>
				<!--
        
          <li><a href="https://twitter.com/artemsheludko_" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
        
        
          <li><a href="https://facebook.com/" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a></li>
        
				-->
        
          <li class="github"><a href="http://github.com/shoark7" target="_blank"><i class="fa fa-github"></i></a></li>
        
        
          <li class="linkedin"><a href="https://in.linkedin.com/in/sunghwan-park-3773b8154" target="_blank"><i class="fa fa-linkedin"></i></a></li>
        
        
          <li class="email"><a href="mailto:shoark7@gmail.com"><i class="fa fa-envelope-o"></i></a></li>
        
      </ul>
    </section> <!-- End Section Contact -->
    <div class="copyright">
      <p>2019 &copy; Sunghwan Park</p>
    </div>
  </footer> <!-- End Footer -->
</aside> <!-- End Sidebar -->

<div class="content-box clearfix">
  <article class="article-page">
  <div class="page-content">
    
    <div class="page-cover-image">
      <figure>
        <img class="page-image" src=/assets/img//algorithm/longest-palindromes-logo.png alt="[Python] Get longest palindromes in string">
        
      </figure>
    </div> <!-- End Page Cover Image -->
    
    <div class="wrap-content">
      <header class="header-page">
        <h1 class="page-title">[Python] Get longest palindromes in string</h1>
        <div class="page-date"><span>2019, Apr 16&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
      </header>
      <h2 id="0-index">0. Index</h2>

<blockquote>
  <ol>
    <li><a href="#1">Prologue</a></li>
    <li><a href="#2">Problem introduction</a></li>
    <li><a href="#3">Way 1: Implement it simple way</a></li>
    <li><a href="#4">Way 2: A more elegant way</a>
      <ul>
        <li>4.1. <a href="#4a">Tuning the subproblem: How to tell a palindrome</a></li>
        <li>4.2. <a href="#4b">Need for a more efficient program</a></li>
        <li>4.3. <a href="#4c">Tuning the subproblem: How to tell a palindrome</a></li>
        <li>4.4. <a href="#4d">Let’s dive into Code</a></li>
      </ul>
    </li>
    <li><a href="#5">Appendix: importance of defining problems</a></li>
    <li><a href="#6">Epilogue</a></li>
  </ol>
</blockquote>

<p><br id="1" /></p>

<h2 id="1-prologue">1. Prologue</h2>

<hr />

<p>This is my second post written totally in English. Well, this post was one of my must-do items but I couldn’t make it because I was too lazy. If you’re intested in algorithm, this subject would be attractive, and maybe a piece of cake to you. Today’s post is about <code class="highlighter-rouge">palindrome</code>. Palindrome is the very famous, easy-to-introduce algorithm for newbies in computer science or any computer languages. But often, it just focuses on telling whether the given string is a palindrome or not. It’s worth noting but we want more, right? So, <strong>today’s post is about ‘getting a list of longest palindromes in a string’. A string can be any sizes long and we have to find all longest palindromes.</strong></p>

<p>I think you wouldn’t know my focus on posts on algorithms because they’re all written in Korean. I try to introduce various solutions on a single problem and to modularize it into several parts. This kind of behavior is really important for other cases and it’s my pride on my algorithm posts.</p>

<p>So, <strong>I’ll solve the problem in 2 ways today: One way is really simple, codes are short and I didn’t put my attention too much because problem itself is not that difficult actually. But, the codes are only written in hands and it’s not good. We’ll see what’s and why’s wrong in first solution. And in 2nd solution, we’ll divide it and solve it continously and assemble them. While doing so, we’ll use dynamic programming and improve time complexity of the algorithm. Also, you’ll get to know this way is much more beautiful and healthy for maintenance, reusabilly and for your mental health.</strong></p>

<p>OK, I was too talkative. Let’s move on and dive into algorithm.</p>

<p><br id="2" /></p>

<h2 id="2-problem-introduction">2. Problem introduction</h2>

<hr />

<p><strong>Today’s post is about ‘getting a list of longest palindromes in a string’. Palindrome is a sequence of characters which reads the same backward as forward, such as ‘<em>hannah</em>’, ‘<em>racecar</em>’, ‘<em>기러기</em>’.</strong> If you’ve studied programming anyhow, I think you might have come across this word or problem related to this. Even if not, it’s okay cause problem is easy and intuitive. We feel comfortable within 2-dimensional areas.</p>

<p>We’re given a string. It can be any string and you have to return a list. Here’s an example.</p>

<p><img src="/assets/img/algorithm/longest-palindromes.png" alt="Example of a get longest palindrome" /></p>

<p>As you can see, somebody emphasizes importance of levelness of the ground for multi-pulpose radars. His words are given as a string. And <strong>we have a function named ‘<em>get_longest_palindromes</em>’ and this function returns longest palindromes.</strong> This sentence has two longest palindromes and they’re ‘level’ and ‘radar’. They’re both 5 chars long. So the returned list has two items inside.</p>

<p>And <strong>if a string has no palindromes(like ‘abc’), it returns a list of all characters([‘a’, ‘b’, ‘c’]) cause a character of one length is a palindrome technically. If an empty string(‘’) is given, we return a list of an empty string(['']).</strong></p>

<p><br id="3" /></p>

<h2 id="3-way-1-implement-it-simple-way">3. Way 1: Implement it simple way</h2>

<hr />

<p>Palindrome is an easy example of many brain-*ucking problems related to string and we can solve it without any sort of deep thinking or taking notes. With definition, we can know that length of longest palindromes is between 0(inclusive) and length of the original string(inclusive). If so, <strong>how about iterating N to 0(not 0 to N) and test all substrings in a string if they’re palindromes. If any substring matches, we can iterate until that candidate length and finish the loop cause we don’t need short palindromes in this problem.</strong></p>

<p>I just created the simple version of ‘<em>get_longest_palindromes</em>’ function. It’s only 2 <em>for</em> loop deep and codes are short too.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_longest_palindromes</span><span class="p">(</span><span class="n">strng</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strng</span><span class="p">)</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>	<span class="c1"># 1.
</span>        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>	<span class="c1"># 2.
</span>            <span class="n">target</span> <span class="o">=</span> <span class="n">strng</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">l</span><span class="p">]</span>
	    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">target</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>	<span class="c1"># 3.
</span>                <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strng</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">l</span><span class="p">])</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">ans</span> <span class="k">if</span> <span class="n">strng</span> <span class="k">else</span> <span class="p">[</span><span class="s">''</span><span class="p">]</span>	<span class="c1"># 4.
</span></code></pre></div></div>

<p>Here’re some comments on codes section 1, 2, 3 and 4.</p>

<ol>
  <li><strong>We first iterate on possible longest length in [N, 1]</strong>
    <ul>
      <li>We don’t need to check 0 because shortest palindromes are one length long if not string is empty.</li>
      <li>And we define <em>found</em> variable to check if we found palindromes in that candidate length. At every end of first loop, we’ll check if <em>found</em> is changed and end the loop if longest palindromes are found and saved.</li>
    </ul>
  </li>
  <li><strong>Check every substring of length <em>l</em> if it is a palindrome</strong>
    <ul>
      <li>Look at the length of iteration of 2nd loop. It’s <script type="math/tex">N-l+1</script>, not <script type="math/tex">N-l</script>. It may seem confusing but simple. If <script type="math/tex">l == N</script>, we have to iterate only once. But if we don’t add 1 in iteration count, no iteration is executed.(<em>N-N</em> is 0 and <em>range(0)</em> is not executed) So we have to add 1. To be honest, I was really confused at first.</li>
    </ul>
  </li>
  <li><strong>Direct codes of checking a substring is a palindrome</strong>
    <ul>
      <li>With length variable(<em>l</em>) and start location of a substring(<em>s</em>), we can retrieve a target substring. And now what’s left is checking it. There can be a lot of ways to check but we use a very easy and intuitive way. <strong><em>Just compare the substring to backwards string.</em></strong>  We used a Python trick to reverse a Sequence backwards. <strong><em>Using -1 stride</em></strong></li>
      <li><strong>If we found palindromes, we append to the <em>ans</em> list and toggle <em>found</em> variable to <em>True</em></strong>.</li>
    </ul>
  </li>
  <li>After all iterations, we return the <em>ans</em>. But We didn’t consider a case of an empty string. If so, return [''] or return <em>ans</em> otherwise.</li>
</ol>

<p><br /></p>

<p>How do you think of this codes? Well, <strong>I can solve it in this way but I won’t recommend this kind of algorithms and approach for the original problem.</strong> I train myself to maintain a negative view on this kind of approach actually. This codes don’t imply any philosophy.</p>

<p>Next algorithm is way more appropriate for this purpose. It needs more time and energy, insight on the question but I assure you that you will be more satisfied with algorithm.</p>

<p><br id="4" /></p>

<h2 id="4-way-2-a-more-elegant-way">4. Way 2: A more elegant way</h2>

<hr />

<p>We checked out an easy solution for the question. Yes, it perfectly works but I don’t like this way. We can be more than what this way insists.</p>

<p>In this chapter, I’ll first explain what’s wrong and missing in the previous solution. And next we’ll cover two improvement proposals: modularizing the problem and using dynamic programming for time complexity.</p>

<p><br id="4a" /></p>

<h3 id="41-easy-one-first-define-subproblem">4.1. Easy one first: define subproblem</h3>

<p>How do you feel about the previous solution above? I just ran into the codes and it just took 5 minutes to weave the code blocks to solve the problem. This problem was not that difficult so this way of working worked well. But if a problem gets slighly more harder and complicated, we won’t be able to make it.</p>

<p><strong>Before solving it, we have to think first and take notes of the problem. And if we can, we have to divide the original problem into easier subproblems so that we can assemble it and solve the original.</strong> Like we play Legos: using many type of blocks and making a full machine.</p>

<p>This way of thinking and dividing the problem would seem tiresome at first. But if the problem keeps getting complicated, we cannot handle it, cause it’s too big and not structured. <strong>You cannot progrm Microsoft Excel in a single function. So think first, define subproblems and lego them into a system.</strong></p>

<p><br /></p>

<p>The original problem is ‘Get list of longest palindromes in a string’. And I divided it into subproblems:</p>

<ol>
  <li><strong>A function that tells if a given string is a palindrome or not.</strong></li>
  <li><strong>How to get the length of longest palindromes in a string.</strong></li>
  <li><strong>Get all longest palindrome substrings and return it into a list.</strong></li>
</ol>

<p>Each subproblem is much easier than the original, complicated and mixed problems. And let’s solve it one by one. Then we would feel no hardship when encountered a harder one.</p>

<hr />

<p><br id="4b" /></p>

<h3 id="42-need-for-a-more-efficient-program">4.2. Need for a more efficient program</h3>

<p>OK, we defined some subproblems. And what’s next? <strong>Problem is much easier than before and we can consider efficiency that we wouldn’t be able to imagine when the problem is too complicated.</strong></p>

<p>Here are the very core part of the previous solution.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">...</span>
<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>	<span class="c1"># 1.
</span>    <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>	<span class="c1"># 2.
</span>        <span class="n">target</span> <span class="o">=</span> <span class="n">strng</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">l</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">target</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>	<span class="c1"># 3.
</span>            <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strng</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">l</span><span class="p">])</span>
            <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
        <span class="k">break</span>

<span class="o">...</span>
</code></pre></div></div>

<p>How would time complexity of the solution be? There are 2 <em>for</em> loops nested and checking if a string is palindrome(sec. 3) is <script type="math/tex">O(n)</script>. So the total time complexity is <script type="math/tex">O(N^3)</script>. There’re some cases that possible best solutions works <script type="math/tex">O(N^3)</script> but normally, this time complexity is not good. It takes <script type="math/tex">10^9</script> calculations even if the input is only 1000. It would take several seconds at least.</p>

<p><strong>With the power of modularity, redefining the problem into subproblems, we can specialize each part and replace inefficient parts with new, better codes.</strong> <strong>Now, I think I can improve the subproblem No.1 among three of them in the previous solution.</strong> It’s about checking a substring.</p>

<p><br id="4c" /></p>

<h3 id="43-tuning-the-subproblem-how-to-tell-a-palindrome">4.3. Tuning the subproblem: How to tell a palindrome</h3>

<p>Our code for checking a substring is a palindrome or not is like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>	<span class="c1"># 1.
</span>    <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>	<span class="c1"># 2.
</span>        <span class="n">target</span> <span class="o">=</span> <span class="n">strng</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">l</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">target</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>	<span class="c1"># 3.
</span>            <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strng</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">l</span><span class="p">])</span>
</code></pre></div></div>

<p>Getting a substring and reversing it is really easy in Python. But at worst cases, we have to check all substrings and this won’t make it.(<script type="math/tex">O(N^3)</script>)</p>

<p><br /></p>

<p>So, let’s define a subfunction <em>is_palindrome</em>. It gets <em>lo</em>, and <em>hi</em> variables, which are the start and end indices of a target substring.(both are inclusive)</p>

<script type="math/tex; mode=display">\begin{align} \label{}
	\text{is_palindrome}(lo, hi): \text{Return bool value of whether a substring(string[lo, hi]) is a palindrome or not}
\end{align}</script>

<p><strong>With this definition, we can induce a recurrence formula:</strong></p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{array} \label{}
	\text{is_palindrome}(lo, hi) =
	  \begin{cases}
	    True & \quad \text{1. if lo == hi},\\
	    string[lo] == string[hi] & \quad \text{2. if lo + 1 == hi},\\
	    \\
	    False & \text{3. if string[lo] != string[hi]},\\
	    \text{is_palindrome}(lo+1, hi-1) & \quad\\
	  \end{cases}
\end{array} %]]></script>

<p>What does this mean? True or not is decided by one case among this conditions.</p>

<ol>
  <li><strong>If <em>lo</em> is same to <em>hi</em>, it means a single substring and the answer is always <em>True</em></strong>.</li>
  <li><strong>If <em>lo+1</em> is same to <em>hi</em>, it means substring is two chars long and the answer is whether each character is same or not.</strong></li>
  <li><strong>Otherwise, it’s divided into 2 cases:</strong>
    <ul>
      <li><strong>If two outermost characters in a substring are different, it cannot be a palindrome and return <em>False</em>.</strong></li>
      <li><strong>Else, we have to check for a smaller substring[<em>lo+1</em>, <em>hi-1</em>].</strong></li>
    </ul>
  </li>
</ol>

<p>Understanding <strong>case 3. is important.</strong> Let’s assume our target substring is ‘ABCBA’. How can we know if it’s a palindrome?</p>

<p><img src="/assets/img/algorithm/longest-palindromes-yes.png" alt="Example of yes palindrome" /></p>

<p><strong>Palindrome is like an onion. When you strip off outermost characters, the left substring is also a palindrome. Outermost characters here are ‘A’, ‘B’ and ‘C’ in sequence. And both edge characters should always match each other in palindrome, and it’s not if they don’t.</strong></p>

<p>So when we finish the first comparing process, comparing outermost chars, we can go to next outermost chars until we reach the base cases defined above: case No 1, 2.</p>

<p><strong>If outermost characters match(<em>if string[lo] == string[hi]</em>), we can call recursive function in the range of [<em>lo+1</em>, <em>hi-1</em>](process No.2).</strong></p>

<p><img src="/assets/img/algorithm/longest-palindromes-no.png" alt="Example of no palindrome" /></p>

<p>However, what about  <strong>if outermost characters are different? Then, string cannot be a palindrome at all. No need to check inner characters. Then return <em>False</em>.</strong></p>

<p><br /></p>

<p>OK. Understood. What can we do now? With recursive function, we can know that if we already know the answer of smaller problems(like <em>[lo+1, hi-1]</em>), it’s easy to know the answer of bigger problem(<em>[lo, hi]</em>). And <strong>we have to store the state(answer) of smaller problems and it’s perfect time to use cache.</strong>. <code class="highlighter-rouge">Dynamic programming</code> is a perfect match here.</p>

<hr />

<p><br id="4d" /></p>

<h3 id="44-lets-dive-into-code">4.4. Let’s dive into Code</h3>

<p>We concluded it’s better to use dynamic programming and let’s implement it in this way.</p>

<p>First, we can create the cache</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_longest_palindromes</span><span class="p">(</span><span class="n">strng</span><span class="p">):</span>  <span class="c1"># 1.
</span>    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strng</span><span class="p">)</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span> <span class="c1"># 2.
</span></code></pre></div></div>

<ol>
  <li>We defined <em>get_longest_palindromes</em> function and it takes ‘strng’ variable.</li>
  <li>Defined a cache.  <strong>Our <em>is_palindrome</em> subfunction takes two elements <em>lo</em>, <em>hi</em>. So we need to track the states related to them. That’s why <em>cache</em> is a 2D matrix.</strong></li>
</ol>

<p><br /></p>

<p>With cache, we can implement <em>get_longest_palindromes</em> function using it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cache</span><span class="p">[</span><span class="n">lo</span><span class="p">][</span><span class="n">hi</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="c1"># 0.
</span>        <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">lo</span><span class="p">][</span><span class="n">hi</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">lo</span> <span class="o">==</span> <span class="n">hi</span><span class="p">:</span> <span class="c1"># 1.
</span>        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">hi</span><span class="p">:</span> <span class="c1"># 2.
</span>        <span class="k">return</span> <span class="n">strng</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span> <span class="o">==</span> <span class="n">strng</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span>

    <span class="c1"># 3.
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="bp">False</span> <span class="k">if</span> <span class="n">strng</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span> <span class="o">!=</span> <span class="n">strng</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span> <span class="k">else</span> <span class="n">is_palindrome</span><span class="p">(</span><span class="n">lo</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">cache</span><span class="p">[</span><span class="n">lo</span><span class="p">][</span><span class="n">hi</span><span class="p">]</span> <span class="o">=</span> <span class="n">ans</span>
    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>Our cache is initialized with <em>None</em> at first. And if we find answer of a problem, we can record it. If it’s not <em>None</em>, we solved this problem before, so no need to repeat it. Just return the answer.</p>

<p>And <strong>section 1, 2 and 3 are just Python implementation of our recurrence formula.</strong> Literally same. If we can induce a recurrence formula, things go easy with coding many times.</p>

<p><strong>If we get answer of range in <em>[lo, hi]</em>, we record it in the cache and return it.</strong></p>

<p>Jule! We finished our first subproblem.</p>

<p><br /></p>

<p>The rest subproblems are:</p>

<ul>
  <li><strong>How to get the length of longest palindromes in a string.</strong></li>
  <li><strong>Get all longest palindrome substrings and return it into a list.</strong></li>
</ul>

<p>But these problemsa are pretty much similar to the codes of first solution. Here are codes solving these 2 subproblmes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_palindromes</span><span class="p">():</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">longest</span> <span class="o">=</span> <span class="n">N</span>
    <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">strng</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">''</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_palindrome</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">+</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strng</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">l</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">ret</span>
</code></pre></div></div>

<p><strong>I created <em>generate_palindromes</em> subfunction getting the longest palindromes using our <em>is_palindrome</em> subfunction.</strong></p>

<p>And we start longest length from N, as we did above. And I set <em>found</em> variable to <em>False</em> and this will be toggled on if we found longest palindromes. Then no more loop iteration is needed. After end of 2nd iteration, we check everytime if <em>found</em> is toggled on and breaks out if it’s <em>True</em></p>

<p><strong>It’s noteworthy that I combined two subproblems into a single subfunction. If a subproblem is too easy, no need to make it a single module. You can assemble it into a bigger one.</strong> In my rule of thumb, when you’re not sure if you have to define a single function or not, it’s better to make it a function and independent. Because it’s easier for maintenance.</p>

<p><br /></p>

<p>OK. All modules are ready. We can combine them into a function solving the original problem.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_longest_palindromes</span><span class="p">(</span><span class="n">strng</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strng</span><span class="p">)</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cache</span><span class="p">[</span><span class="n">lo</span><span class="p">][</span><span class="n">hi</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">lo</span><span class="p">][</span><span class="n">hi</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">lo</span> <span class="o">==</span> <span class="n">hi</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">hi</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">strng</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span> <span class="o">==</span> <span class="n">strng</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="bp">False</span> <span class="k">if</span> <span class="n">strng</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span> <span class="o">!=</span> <span class="n">strng</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span> <span class="k">else</span> <span class="n">is_palindrome</span><span class="p">(</span><span class="n">lo</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">lo</span><span class="p">][</span><span class="n">hi</span><span class="p">]</span> <span class="o">=</span> <span class="n">ans</span>
        <span class="k">return</span> <span class="n">ans</span>

    <span class="k">def</span> <span class="nf">generate_palindromes</span><span class="p">():</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">longest</span> <span class="o">=</span> <span class="n">N</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">strng</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="s">''</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_palindrome</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">+</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strng</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="n">l</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">return</span> <span class="n">generate_palindromes</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">get_longest_palindromes</span><span class="p">(</span><span class="s">'hannah'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">get_longest_palindromes</span><span class="p">(</span><span class="s">'racecar'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">get_longest_palindromes</span><span class="p">(</span><span class="s">'foobarisreadytogo'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">get_longest_palindromes</span><span class="p">(</span><span class="s">'abcdef'</span><span class="p">))</span>
 <span class="k">print</span><span class="p">(</span><span class="n">get_longest_palindromes</span><span class="p">(</span><span class="s">''</span><span class="p">))</span>


<span class="p">[</span><span class="s">'hannah'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'racecar'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'ogo'</span><span class="p">]</span>
<span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">,</span> <span class="s">'f'</span><span class="p">]</span>
<span class="p">[</span><span class="s">''</span><span class="p">]</span>
</code></pre></div></div>

<p>I admit that codes are much longer than before. However, our purpose is not making a short program but a more beaufitul and efficient program. <strong>What benefits have this solution gained?</strong></p>

<ul>
  <li><strong>Readability: With defining subproblems and making them modules, readability improved. And that’s why we define problems and modularize blocks.</strong></li>
  <li><strong>Efficiency: As readability is improved, we can talk about better efficiency. Amongst subfunctions, bottleneck part is ‘checking a string is a palindrome’. We can profile a program better and we changed <em>is_palindrome</em> function in design level. And if we find a better solution than dynamic programming, no need to make a mess. Just improve the codes of a subfunction. Much, much more easy.</strong></li>
</ul>

<p>By the way, what is time complexity of this solution? <strong>We know that ‘checking a palindrome’ was a bottleneck. And time complexity of <em>is_palindrome</em> function is <script type="math/tex">O(N^2)</script> cause cache size is <script type="math/tex">(N^2)</script>. So the total time complexity is <script type="math/tex">O(N^2)</script>, much better than <script type="math/tex">O(N^3)</script>, complexity of the previous one.</strong></p>

<p><br /></p>

<p>OK, we made a better solution with power of defining subproblems, modularity and assembly of them into a final solution.</p>

<p><br id="5" /></p>

<h2 id="5-appendix-importance-of-defining-problems">5. Appendix: importance of defining problems</h2>

<hr />

<p>When I first solved the problem, my solution didn’t use ‘checking a palindrome’ part. In our functions, we define <em>is_palindrome</em> function and its specification is like this:</p>

<script type="math/tex; mode=display">\begin{align} \label{}
	\text{is_palindrome}(lo, hi): \text{Return bool value of whether a substring(string[lo, hi]) is a palindrome or not}
\end{align}</script>

<p>This is how we defined a subproblem. But I didn’t mention it’s the only or best to way solve the problem. My first solution defined the other function to use dynamic programming:</p>

<script type="math/tex; mode=display">\begin{align} \label{}
	\text{length_of_longest}(lo, hi): \text{Return length of longest palindrome in a substring(string[lo, hi])}
\end{align}</script>

<p>While our code stored True or False if the substring in range [<em>lo</em>, <em>hi</em>] is a palindrome or not, <strong>my original function stored length of longest palindromes in range [<em>lo</em>, <em>hi</em>]. So if substring were ‘abac’, stored value would be ‘3’, not ‘False’.</strong></p>

<p>And with this subfunction, you can also solve the problem too, but it gets much more messy.</p>

<p><strong>I recommend you to solve the same problem with this subfunction. I got to know importance of defining (sub)problems. Whole codes and solution is totally changed for the same problem and I even used dynamic programming there too.</strong> It’s really interesting and implies a lot. Remember, define the problems first. It directs where you should go, and controls whole logic.</p>

<p><br /></p>

<h2 id="6-epilogue">6. Epilogue</h2>

<hr />

<p>We looked through the ways to solve ‘Get longest palindromes in a given string’. First was simple but not considered enough. Solution was made of just one block so handling it was not easy. But the second one was much better. <strong>It took more time and codes to define subproblems and assemble them, but much better in the sense of efficiency, readability and maintenance.</strong></p>

<p>To be honest, I feel less confident on this post. <strong>I’m not sure if my first purpose is accomplished for readers: Emphasizing importance of modularity and deep thinking before diving into coding.</strong> English words are confusing and I feel strange to type in English now. I cannot say my semi-major was English Literature and I’m shameful :P. I hope you guys understand flaws in my English.</p>

<p>But I feel relieved that I just ended the post of one of my candidate subjects piled up in my head.</p>

<p>What would be the next topic? Anything would be good if it interests me and you. :)</p>

<p>Post ended.</p>

      <div class="page-footer">
        <div class="page-share">
          <a href="https://twitter.com/intent/tweet?text=[Python] Get longest palindromes in string&url=https://shoark7.github.io/programming/algorithm/get-longest-palindromes-in-string" title="Share on Twitter" rel="nofollow" target="_blank">Twitter</a>
          <a href="https://facebook.com/sharer.php?u=https://shoark7.github.io/programming/algorithm/get-longest-palindromes-in-string" title="Share on Facebook" rel="nofollow" target="_blank">Facebook</a>
          <a href="https://plus.google.com/share?url=https://shoark7.github.io/programming/algorithm/get-longest-palindromes-in-string" title="Share on Google+" rel="nofollow" target="_blank">Google+</a>
        </div>
        <div class="page-tag">
          
            <a href="/tags#Palindrome" class="tag">&#35; Palindrome</a>
          
            <a href="/tags#Dynamic_programming" class="tag">&#35; Dynamic_programming</a>
          
        </div>
      </div>
		  <!-- Load Facebook SDK for JavaScript -->
  <div id="fb-root"></div>
  <script>(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v3.0";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));</script>

  <!-- Your share button code -->
  <div class="fb-share-button" 
    data-href="https://shoark7.github.io/programming/algorithm/get-longest-palindromes-in-string" 
    data-layout="button_count">
  </div>

		
    </div> <!-- End Wrap Content -->
  </div> <!-- End Page Content -->
</article> <!-- End Article Page -->

</div>

  </div>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '', 'auto');
  ga('send', 'pageview');
</script> <!-- End Analytics -->

	<script src="https://unpkg.com/simple-jekyll-search@1.5.0/dest/simple-jekyll-search.min.js"></script>
<script>
var sjs = SimpleJekyllSearch({
  searchInput: document.querySelector('#search-input'),
  resultsContainer: document.getElementById('results-container'),
  json: '/search.json',
  searchResultTemplate: '<li class="search-results-item"><a href="https://shoark7.github.io{url}">{title}</a></li>',
	limit: 9,
	noResultsText: '<li class="search-results-item"><a href="#">No results found...</a></li>'
})
</script>

	<!-- Main Js -->
<!--<script src="/assets/js/main.js"></script>-->

<!-- JQuery 3.x min -->
<script src="/assets/js/jquery.js"></script>

<script>
	let menus = $("#category-list");
	let image = $("#menu-toggler img");
	$("#toggler-wrapper").click(function() {
		if(menus.css("display") === "none") {
			image.attr("src", "/assets/img/close-button.png");
			menus.css("display", "flex");
		}
		else {
			image.attr("src", "/assets/img/nav-off.png");
			menus.css("display", "none");
		}
	});


</script>

	<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-127149179-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-127149179-1');
</script>

</body>
</html>
